#!/usr/bin/python3

no_escape={
	'ps.t': 1,
	'..url': 1,
}

hotkeys='''
/home/scott/figlet/Caligraphy.figlet
'''
hotkeys='''
	*                              *
**                       *     **
**                      **     **
**                      **     **
**           ****     ******** **                   **   ****         ****
**  ***     * ***  * ********  **  ***       ***     **    ***  *    * **** *
** * ***   *   ****     **     ** * ***     * ***    **     ****    **  ****
***   *** **    **      **     ***   *     *   ***   **      **    ****
**     ** **    **      **     **   *     **    ***  **      **      ***
**     ** **    **      **     **  *      ********   **      **        ***
**     ** **    **      **     ** **      *******    **      **          ***
**     ** **    **      **     ******     **         **      **     ****  **
**     **  ******       **     **  ***    ****    *   *********    * **** *
**     **   ****         **    **   *** *  *******      **** ***      ****
 **    **                       **   ***    *****             ***
	*                                               *****   ***
	*                                              ********  **
	*                                              *      ****
	*
'''
hotkeys='''
/home/scott/figlet/Isometric2.figlet
'''
hotkeys='''
	___           ___                         ___           ___                       ___
	/\\  \\         /\\  \\                       /|  |         /\\__\\                     /\\__\\
	\\:\\  \\       /::\\  \\         ___         |:|  |        /:/ _/_         ___       /:/ _/_
	\\:\\  \\     /:/\\:\\  \\       /\\__\\        |:|  |       /:/ /\\__\\       /|  |     /:/ /\\  \\
	___ /::\\  \\   /:/  \\:\\  \\     /:/  /      __|:|  |      /:/ /:/ _/_     |:|  |    /:/ /::\\  \\
 /\\  /:/\\:\\__\\ /:/__/ \\:\\__\\   /:/__/      /\\ |:|__|____ /:/_/:/ /\\__\\    |:|  |   /:/_/:/\\:\\__\\
 \\:\\/:/  \\/__/ \\:\\  \\ /:/  /  /::\\  \\      \\:\\/:::::/__/ \\:\\/:/ /:/  /  __|:|__|   \\:\\/:/ /:/  /
	\\::/__/       \\:\\  /:/  /  /:/\\:\\  \\      \\::/~~/~      \\::/_/:/  /  /::::\\  \\    \\::/ /:/  /
	 \\:\\  \\        \\:\\/:/  /   \\/__\\:\\  \\      \\:\\~~\\        \\:\\/:/  /   ~~~~\\:\\  \\    \\/_/:/  /
	\\:\\__\\        \\::/  /         \\:\\__\\      \\:\\__\\        \\::/  /         \\:\\__\\     /:/  /
	\\/__/         \\/__/           \\/__/       \\/__/         \\/__/           \\/__/     \\/__/
'''
hotkeys='''
/home/scott/figlet/NScript.figlet
'''
hotkeys='''
 ,ggg,        gg                    ,ggg,      gg      ,gg
dP""Y8b       dP                   dP""Y8a     88     ,8P
Yb, `88      d8'                   Yb, `88     88     d8'
 `"  88    ,dP'                     `"  88     88     88   gg
	88aaad8"                           88     88     88   ""
	88""""Yb,     ,ggg,   gg     gg    88     88     88   gg     ,g,      ,ggg,
	88     "8b   i8" "8i  I8     8I    88     88     88   88    ,8'8,    i8" "8i
	88      `8i  I8, ,8I  I8,   ,8I    Y8    ,88,    8P   88   ,8'  Yb   I8, ,8I
	88       Yb, `YbadP' ,d8b, ,d8I     Yb,,d8""8b,,dP  _,88,_,8'_   8)  `YbadP'
	88        Y8888P"Y888P""Y88P"888     "88"    "88"   8P""Y8P' "YY8P8P888P"Y888
								,d8I'
							,dP'8I
							,8"  8I
							I8   8I
							`8, ,8I
							`Y8P"
'''
hotkeys='''
/home/scott/figlet/Poison.figlet
'''
hotkeys='''
@@@  @@@  @@@@@@@@  @@@ @@@  @@@  @@@  @@@  @@@   @@@@@@   @@@@@@@@
@@@  @@@  @@@@@@@@  @@@ @@@  @@@  @@@  @@@  @@@  @@@@@@@   @@@@@@@@
@@!  !@@  @@!       @@! !@@  @@!  @@!  @@!  @@!  !@@       @@!
!@!  @!!  !@!       !@! @!!  !@!  !@!  !@!  !@!  !@!       !@!
@!@@!@!   @!!!:!     !@!@!   @!!  !!@  @!@  !!@  !!@@!!    @!!!:!
!!@!!!    !!!!!:      @!!!   !@!  !!!  !@!  !!!   !!@!!!   !!!!!:
!!: :!!   !!:         !!:    !!:  !!:  !!:  !!:       !:!  !!:
:!:  !:!  :!:         :!:    :!:  :!:  :!:  :!:      !:!   :!:
 ::  :::   :: ::::     ::     :::: :: :::    ::  :::: ::    :: ::::
 :   :::  : :: ::      :       :: :  : :    :    :: : :    : :: ::
'''
hotkeys='''
/home/scott/figlet/Block.figlet
'''
hotkeys='''
_|    _|                      _|          _|  _|
_|  _|      _|_|    _|    _|  _|          _|        _|_|_|    _|_|
_|_|      _|_|_|_|  _|    _|  _|    _|    _|  _|  _|_|      _|_|_|_|
_|  _|    _|        _|    _|    _|  _|  _|    _|      _|_|  _|
_|    _|    _|_|_|    _|_|_|      _|  _|      _|  _|_|_|      _|_|_|
						_|
					_|_|
'''
hotkeys='''
/home/scott/figlet/3-D.figlet
'''
hotkeys='''
 **      **            **   **
/**     /**           /**  /**              **   **
/**     /**  ******  ******/**  **  *****  //** **   ******
/********** **////**///**/ /** **  **///**  //***   **////
/**//////**/**   /**  /**  /****  /*******   /**   //*****
/**     /**/**   /**  /**  /**/** /**////    **     /////**
/**     /**//******   //** /**//**//******  **      ******
//      //  //////     //  //  //  //////  //      //////
'''
# ## {R2D2919B742E} ##
# ###########################################################################
# What if magic existed?
# What if a place existed where your every thought and dream come to life.
# There is only one catch: it has to be written down.
# Such a place exists, it is called programming.
#    - Scott Taylor Reph, RightThumb.com
# ###########################################################################
# ## {C3P0D40fAe8B} ##
##################################################
import os, sys, time
##################################################
import _rightThumb._construct as __
appDBA = __.clearFocus( __name__, __file__ )
__.appReg = appDBA
def focus( parentApp='', childApp='', reg=True ):
	global appDBA
	f = __.appName( appDBA, parentApp, childApp )
	if reg:
		__.appReg = f
	return f
__.registeredApps.append( focus() )
import _rightThumb._base3 as _
_.load()
##################################################
_.v.play = True

banner=_.Banner(hotkeys);
# print(hotkeys)
goss=banner.goss
goss('-\t search hotkeys with the hk command')
goss('-\t\t hk space')
goss('-\t\t\t remove-eol-space ctrl,2 space e')
goss('-\t\t\t dup-spaces ctrl win s')
goss('-\t\t\t clip-single-space win shift alt s')
goss('-\t\t\t clip-double-space win shift alt d')
goss('-\t\t\t clip-dup-spaces ctrl,2 r d s')


##################################################
import _rightThumb._vars as _v
import _rightThumb._string as _str
##################################################
from inspect import currentframe, getframeinfo
frameinfo = getframeinfo(currentframe())
from threading import Timer
import re
import regex
try:
	import winsound
except Exception as e:
	frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
	pass
simplejson = __.imp('simplejson')

##################################################

def appSwitches():
	_.switches.register( 'Print-Keys', '-print' )
	_.switches.register( 'Convert-AutoText', '-autotext' )
	_.switches.register( 'Add-Text-Trigger', '-add' )
	_.switches.register( 'Add-Text-Text', '-text' )
	_.switches.register( 'Add-Text-Back', '-back' )
	_.switches.register( 'Add-Text-Note', '-note' )
	_.switches.register( 'Key-Subject', '-k,-key,-keys,?k,?keys,-subject,-sub' )
	_.switches.register( 'Files', '-f,-fi,-file,-files','file.txt', isData='data', description='Files', isRequired=False )
	_.switches.register( 'Password', '-password' )

#   finds the file in probable locations
#   and
#       if  _.autoBackupData = True
#       and __.releaseAcquiredData = True
#           GET EPOCH FROM: hosts/hostname/logs/apps/execution_receipt-app_name-epoch.json
#       you can run apps on usb at a clients office
#           when you get home run: p app -loadepoch epoch
#               backed up
#                   pipe
#                   files
#                   tables
_.autoBackupData = __.autoCreationConfiguration['backup']
__.releaseAcquiredData = __.autoCreationConfiguration['logs']
__.myFileLocations_SKIP_VALIDATION = False
__.isRequired_Pipe = False
__.isRequired_Pipe_or_File = False
__.pre_error = False
__.switch_raw = []
# __.switch_raw = [ 'Delim' ]
# __.isRequired_or_List = ['Pipe','Files','Plus']
# __.setting( 'app-switches-raw', [ 'Delim' ] )



_.appInfo[focus()] = {
	'banner': banner,
	'file': 'hotkeys.py',
	'liveAppName': __.thisApp( __file__ ),
	'description': 'hotkeys',
	'categories': [
						'hotkeys',
				],
	'usage': [
						# 'epy another',
						# 'e nmap',
						# '',
	],
	'relatedapps': [
						# 'p another -file file.txt',
						# '',
	],
	'prerequisite': [
						# 'p another -file file.txt',
						# '',
	],
	'examples': [
						_.hp('p hotkeys'),
						_.hp('p hotkeys'),
						_.hp('p hotkeys'),
						'',
						_.hp('p hotkeys -add ...lines -text "sum(1 for line in open(''))" -back 2 -note python-file-lines'),
						'#      IF YOU DO NOT USE -text when -add it will take from the copied clipboard',
						_.hp('p hotkeys -add ...lines -back 2 -note python-file-lines'),
						'',
						'hk imp',
						'',
	],
	'columns': [
					# { 'name': 'name', 'abbreviation': 'n' },
					# { 'name': '{1}', 'abbreviation': '{0}', 'sort': '{2}' },
	],
	'aliases': [
					# 'this',
					# 'app',
	],
	'notes': [
					# {},
	],
}



_.appData[focus()] = {
		'start': __.startTime,
		'uuid': '',
		'audit': [],
		'pipe': False,
		'data': {
					'field': {'sent': [], 'received': [] }, # { 'label': '', 'context': [],  }
					'table': {'sent': [], 'received': [] },
		},
	}



def registerSwitches( argvProcessForce=False ):
	global appDBA
	if not __.appReg == appDBA and appDBA in __.appReg:

		if not __name__ == '__main__':
			_.argvProcess = argvProcessForce
		else:
			_.argvProcess = True

		_.load()
		_.appInfo[__.appReg] = _.appInfo[appDBA]
		_.appData[__.appReg] = _.appData[appDBA]
	__.constructRegistration( _.appInfo[__.appReg]['file'],__.appReg )
	appSwitches()

	_.myFileLocation_Print = False
	_.switches.trigger( 'Files', _.myFileLocations, vs=True )
	_.switches.trigger( 'Folder', _.myFolderLocations )
	_.switches.trigger( 'URL', _.urlTrigger )
	_.switches.trigger( 'Ago', _.timeAgo )
	_.switches.trigger( 'Duration', _.timeFuture )
	# _.switches.trigger( 'Files',_.inRelevantFolder )

	_.defaultScriptTriggers()
	_.switches.process()


if not __name__ == '__main__':
	_.argvProcess = False
else:
	_.argvProcess = True

registerSwitches()


def fieldSet( switchName, switchField, switchValue, theFocus=False ):
	if not type( theFocus ) == bool:
		theFocus = theFocus
	_.switches.fieldSet( switchName, switchField, switchValue, theFocus )


if __name__ == '__main__':
	if not sys.stdin.isatty():
		_.setPipeData( sys.stdin.readlines(), __.appReg, clean=True )


_.postLoad( __file__ )

########################################################################################
#   if os.path.isdir( row ):
#   if os.path.isfile( row ):
#   os.path.abspath(path)
#                                                   if platform.system() == 'Windows':
########################################################################################
# START


last_f12 = 0

def press_f12():
	import time
	from pynput.keyboard import Key, Controller

	global last_f12
	now = time.time()
	if now - last_f12 < 0.5:
		return
	last_f12 = now
	keyboard = Controller()
	keyboard.press(Key.f12)
	keyboard.release(Key.f12)




# def runAirTerminal():
# 	import keyboard
# 	import sys

# 	class Air_Terminal:
# 		'''
# 		AirTerminal captures key input after a hotkey (e.g., Alt+A), parses it into
# 		virtual switches, and returns a structured dictionary.

# 		Example usage:

# 			term = AirTerminal()

# 			print("âœ… AirTerminal is running... Press Alt+A to activate input mode.")
# 			keyboard.wait()

# 		Example input (typed after pressing Alt+A):

# 			-f file.txt + one two --omit

# 		Output:

# 			{
# 				'-f': 'file.txt',
# 				'+': ['one', 'two'],
# 				'-omit': ''
# 			}
# 		'''
		
# 		'''
# 		if __name__ == '__main__':
# 			term = AirTerminal()

# 			def clean_exit():
# 				print("\nðŸ‘‹ Exiting AirTerminal...")
# 				keyboard.unhook_all_hotkeys()
# 				sys.exit(0)

# 			# First hotkey bind
# 			term.alt_a_hook = keyboard.add_hotkey('alt+a', term.run_once)
# 			keyboard.add_hotkey('alt+esc', clean_exit)

# 			print("âœ… AirTerminal is running...")
# 			print("   â€¢ Press Alt+A to type switches")
# 			print("   â€¢ Press Alt+Esc or Ctrl+C to exit")

# 			try:
# 				keyboard.wait()
# 			except KeyboardInterrupt:
# 				clean_exit()
# 		'''

# 		def __init__(self):
# 			self.raw_text = ''
# 			self.switches = {}
# 			self.alt_a_hook = None
# 			self.active = False

# 		def get_hidden_input_until_enter(self):
# 			keys = []
# 			while self.active:
# 				event = keyboard.read_event(suppress=True)
# 				if event.event_type == keyboard.KEY_DOWN:
# 					key = event.name
# 					if key == 'enter':
# 						break
# 					if key == 'backspace':
# 						if keys:
# 							keys.pop()
# 					else:
# 						keys.append(key)

# 			self.raw_text = ''.join(' ' if k == 'space' else k for k in keys)
# 			return self.raw_text

# 		def parse_virtual_switches(self, raw_text=None):
# 			if raw_text is None:
# 				raw_text = self.raw_text

# 			tokens = raw_text.strip().split()
# 			switches = {}
# 			current = None

# 			for token in tokens:
# 				if token.startswith('--'):
# 					token = '-' + token[2:]

# 				if token.startswith('-') or token.startswith('+'):
# 					current = token
# 					if current not in switches:
# 						switches[current] = []
# 				else:
# 					if current is None:
# 						continue
# 					switches[current].append(token)

# 			for k in list(switches.keys()):
# 				if isinstance(switches[k], list) and len(switches[k]) == 1:
# 					switches[k] = switches[k][0]

# 			self.switches = switches
# 			self.active = False
# 			return switches

# 		def get_switches(self):
# 			print("Air Terminal Started â€” type your switches and press Enter...")
# 			self.get_hidden_input_until_enter()
# 			switches = self.parse_virtual_switches()
# 			print("Air Terminal Stopped")
# 			return switches

# 		def run_once(self):
# 			self.active = True

# 			# ## If not in hotkeys
# 			# # Unregister hotkey so it can't be double-triggered
# 			# if self.alt_a_hook:
# 			# 	keyboard.remove_hotkey(self.alt_a_hook)
# 			# 	self.alt_a_hook = None



# 			keyboard.release('alt')
# 			keyboard.release('alt')
# 			switches = self.get_switches()
# 			print('\n[Parsed Switches]', switches)
# 			keyboard.release('alt')
# 			keyboard.release('alt')


# 			# ## If not in hotkeys
# 			# # Re-register hotkey after session
# 			# self.alt_a_hook = keyboard.add_hotkey('alt+a', self.run_once)

# 	term = Air_Terminal()
# 	term.run_once()
# 	return term.switches



def runAirTerminal():
	import keyboard as airKeyboard
	class Air_Terminal:
		def get_hidden_input_until_enter(self):
			keys = []
			while True:
				event = airKeyboard.read_event(suppress=True)
				if event.event_type == airKeyboard.KEY_DOWN:
					key = event.name
					if key == 'enter':
						break
					if key == 'backspace':
						if keys:
							keys.pop()
					else:
						keys.append(key)
			return ''.join(' ' if k == 'space' else k for k in keys)

		def parse_virtual_switches(self, raw_text):
			tokens = raw_text.strip().split()
			switches = {}
			current = None
			for token in tokens:
				if token.startswith('--'):
					token = '-' + token[2:]
				if token.startswith('-') or token.startswith('+'):
					current = token
					switches[current] = []
				else:
					if current:
						switches[current].append(token)
			for k in list(switches.keys()):
				if len(switches[k]) == 1:
					switches[k] = switches[k][0]
			return switches

		def run(self):
			raw = self.get_hidden_input_until_enter()
			return self.parse_virtual_switches(raw)


	terminal = Air_Terminal()
	switches = terminal.run()
	__.AirTerminalSwitches = switches
	# print(switches)
	return switches





def AirTerminal():
	_paste = _.regImp( __.appReg, '-paste' )
	pa =_paste.imp.paste()
	# term = Air_Terminal()
	# term.run_once()
	beepy.simple_beep2()
	switches = runAirTerminal()
	switches = __.AirTerminalSwitches
	print('AirTerminal',switches)
	beepy.simple_beep2()
	
	# try:
	# 	keyboard.release('alt')
	# except: pass
	if '+' in switches:
		# print('has plus')
		Plus = switches['+']
	else:
		# print('no plus')
		Plus = ''

	if '-' in switches:
		# print('has minus')
		Minus = switches['-']
	else:
		# print('no minus')
		Minus = ''

	# print('pa',pa)
	new = []
	for line in pa.split('\n'):
		# print('has',line)
		if _.showLine(line,Plus,Minus):
			# print('kept',line)
			new.append(line)
	text = '\n'.join(new)
	# print('text',text)
	_copy = _.regImp( __.appReg, '-copy' )
	_copy.imp.copy( text )


__.BackupOnSave = _.dot()
__.BackupOnSave.status = False
__.BackupOnSave.file = []
def BackupOnSave():
	def onSave():
		beepy.simple_beep2()
		
		appReg=__.appReg
		_bk = _.regImp( __.appReg, 'fileBackup' )
		_bk.switch( 'Silent' )
		_bk.switch( 'isPreOpen' )
		for path in __.BackupOnSave.file:
			print(f"[Watchdog] Backup: {path}")
			_bk.switch( 'Input', path )
		bkfi = _bk.action()
		__.appReg=appReg
	
	vs = ' - Visual Studio Code'
	sub = ' - Sublime Text'
	title = copy_active_window()

	if vs in title:
		path = title.replace(vs,'')
		if os.path.isfile(path):
			__.BackupOnSave.status = True
			__.BackupOnSave.file.append(path)
			beepy.simple_beep2()
			beepy.simple_beep2()
			# monitor_file(path, onSave)
			import threading
			thread = threading.Thread(target=monitor_file, args=(path, onSave), daemon=True)
			thread.start()
		else:
			print('No file, unable to monitor save and backup')

	elif sub in title:
		path = title.split(' â€¢ ')[0]
		if os.path.isfile(path):
			__.BackupOnSave.status = True
			__.BackupOnSave.file.append(path)
			beepy.simple_beep2()
			beepy.simple_beep2()
			# monitor_file(path, onSave)
			import threading
			thread = threading.Thread(target=monitor_file, args=(path, onSave), daemon=True)
			thread.start()
		else:
			print('No file, unable to monitor save and backup')
	else:
		print('File Save Monitor Only Works From Visual Studio Code or Sublime Text')



def copy_active_window():
	import pygetwindow as gw # type: ignore
	win = gw.getActiveWindow()
	if win:
		return win.title
	return ''



def monitor_file(file_path, on_save_function):
	from watchdog.observers import Observer  # type: ignore
	from watchdog.events import FileSystemEventHandler  # type: ignore
	import time
	import os

	class SaveHandler(FileSystemEventHandler):
		def on_modified(self, event):
			if event.src_path == os.path.abspath(file_path):
				print(f"[Watchdog] Detected save: {file_path}")
				on_save_function()

	observer = Observer()
	handler = SaveHandler()
	folder = os.path.dirname(os.path.abspath(file_path))
	observer.schedule(handler, folder, recursive=False)
	observer.start()
	print(f"[Watchdog] Monitoring: {file_path}")

	try:
		while __.BackupOnSave.status:
			time.sleep(1)
	except KeyboardInterrupt:
		pass  # Optional: handle Ctrl+C gracefully
	finally:
		observer.stop()
		observer.join()
		print(f"[Watchdog] Stopped: {file_path}")






def SaveFileFolderFlag(path, flag):
	# Load or initialize the flag meta table
	flag_data = _.getTable('flag.meta')

	if 'folders' not in flag_data:
		flag_data['folders'] = {}
	if 'files' not in flag_data:
		flag_data['files'] = {}

	paths = [path]

	if flag is None:
		flag = '-'

	# Folders logic
	if os.path.isdir(path):
		if flag == 'close':
			for folder_path, notes in flag_data['folders'].items():
				for note in notes:
					if note.get('status') and folder_path in paths:
						note['status'] = False
						note['closed'] = time.time()
			_.saveTable(flag_data, 'flag.meta')
			return

		found = []
		for folder_path, notes in flag_data['folders'].items():
			for note in notes:
				if note.get('status') and folder_path in paths:
					note['notes'].append({'note': flag, 'time': time.time()})
					found.append(folder_path)

		for target_path in paths:
			if target_path in found:
				continue
			if target_path not in flag_data['folders']:
				flag_data['folders'][target_path] = []
			if not flag == '-':
				flag_data['folders'][target_path].append({
					'status': True,
					'notes': [{'note': flag, 'time': time.time()}],
					'opened': time.time(),
					'closed': None
				})
			else:
				flag_data['folders'][target_path].append({
					'status': True,
					'notes': [],
					'opened': time.time(),
					'closed': None
				})

	# Files logic
	if os.path.isfile(path):  # You might want to change this to os.path.isfile(path)
		if flag == 'close':
			for file_path, notes in flag_data['files'].items():
				for note in notes:
					if note.get('status') and file_path in paths:
						note['status'] = False
						note['closed'] = time.time()
			_.saveTable(flag_data, 'flag.meta')
			return

		found = []
		for file_path, notes in flag_data['files'].items():
			for note in notes:
				if note.get('status') and file_path in paths:
					note['notes'].append({'note': flag, 'time': time.time()})
					found.append(file_path)

		for target_path in paths:
			if target_path in found:
				continue
			if target_path not in flag_data['files']:
				flag_data['files'][target_path] = []
			if not flag == '-':
				flag_data['files'][target_path].append({
					'status': True,
					'notes': [{'note': flag, 'time': time.time()}],
					'opened': time.time(),
					'closed': None
				})
			else:
				flag_data['files'][target_path].append({
					'status': True,
					'notes': [],
					'opened': time.time(),
					'closed': None
				})
	_.saveTable(flag_data, 'flag.meta')


def FlagFileFolder():
	flag=None
	_paste = _.regImp( __.appReg, '-paste' )
	pa = _paste.imp.paste()

	if not pa.startswith(':') and os.path.exists(pa):
		beepy.simple_beep2()
		beepy.simple_beep2()
		# print('Flag: clipboard path')
		print(0)
		SaveFileFolderFlag(pa,flag)


	else:
		if pa.startswith(':'):
			flag = pa[1:]


		vs = ' - Visual Studio Code'
		sub = ' - Sublime Text'
		title = copy_active_window()

		if vs in title:
			path = title.replace(vs,'').strip()
			if os.path.isfile(path):
				beepy.simple_beep2()
				beepy.simple_beep2()
				print(1)
				SaveFileFolderFlag(path,flag)


		elif sub in title:
			path = title.split(' â€¢ ')[0].strip()
			if os.path.isfile(path):
				beepy.simple_beep2()
				beepy.simple_beep2()
				print(2)
				SaveFileFolderFlag(path,flag)








def wt_implode(text):
	# text = text.replace('\n',', ')
	text = text.replace('\r','')
	text=_str.replaceDuplicate( text, ' ' )
	try:
		if '{ "keys":' in text and '"command":' in text:
			text = text.replace('[','')
			text = text.replace(']','')
			text = text.replace('{ "keys":','\n{ "keys":')
			text = text.replace(' } }, ',' } }')
			lines = text.split('\n')
			lines.sort()
			lines.reverse()
			for i,line in enumerate(lines):
				line=line.strip()
				if i and line:
					lines[i] = line+','
			lines.reverse()
			text = '['
			text += '\n,'.join(lines)
			text += '\n]'
			text = text.replace('\n,','\n')
			text = text.replace(', ,',',')
			text = text.replace(',,',',')
			text = text.replace('}{ "command":','},\n{ "command":')
	except Exception as e:
		_.pr('err',e)
	return text

def reorder_keys(data):
	has=False
	if type(data) == list:
		ndata = []
		for item in data:
			if 'command' in item and 'keys' in item:
				has=True
				new = {}
				new['keys'] = item['keys']
				new['command'] = item['command']
				for key in item:
					if not key in 'keys,command'.split(','): new[key] = item[key]
				ndata.append(new)
			else:
				ndata.append(item)
	if has: return ndata
	return data

def remove_html_comments(html_string,test=1):
	import re
	comment_pattern = re.compile(r'<!--.*?-->', re.DOTALL)
	return re.sub(comment_pattern, '', html_string)

def extract_text_from_webpage(text):
	from bs4 import BeautifulSoup
	soup = BeautifulSoup(text, 'html.parser')
	text = '\n'.join(soup.stripped_strings)
	return text



import _rightThumb._beep as _beeper
__.v.beep.timer=False
def extract_urls0(text):
	url_pattern = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
	urls = re.findall(url_pattern, text)
	return urls

def scrape_windows_file_pathsA(text):
	text=text.replace('\\\\','\\')
	windows_path_pattern = r'[a-zA-Z]:[\\/](?:[^<>:"\\/|?*\s]+[\\/]?)*'
	windows_paths = re.findall(windows_path_pattern, text)
	return windows_paths




def scrape_windows_file_pathsBB(text):
	text = text.replace('\\\\', '\\')
	windows_path_pattern = r'(?:[a-zA-Z]:)?[\\/](?:[\w\s.-]+[\\/])+[\w\s.-]+(?:\.[\w]+)?'
	windows_paths = re.findall(windows_path_pattern, text)
	return windows_paths

def scrape_windows_file_paths2BB(text):
	text = text.replace('\\\\', '\\')
	windows_path_pattern = r'(?:\b[a-zA-Z]:)?\\(?:[\w\s.-]+\\)*[\w\s.-]+(?:\.[\w]+)?'
	windows_paths = re.findall(windows_path_pattern, text)
	return windows_paths



def scrape_windows_file_paths(text):
	text = text.replace('\\\\', '\\')
	windows_path_pattern = r'(?:[a-zA-Z]:)?(?:[\\/])?(?:[^<>:"\\/|?*\s]+[\\/])+(?:[^<>:"\\/|?*\s]+[\\/]?)*'
	windows_paths = re.findall(windows_path_pattern, text)
	return windows_paths

def scrape_windows_file_paths2(text):
	text = text.replace('\\\\', '\\')
	# Update the regular expression pattern to match only drive letters followed by a colon (":").
	# The pattern ensures that the second character is a colon (":").
	windows_path_pattern = r'\b[a-zA-Z]:\\(?:[^\\<>:"|?*\r\n]+\\)*[^\\<>:"|?*\r\n]+\b'
	windows_paths = re.findall(windows_path_pattern, text)
	return windows_paths

from bs4 import BeautifulSoup
import urllib.parse


def extract_urls(html_string, base_url=None):
	soup = BeautifulSoup(html_string, 'html.parser')
	urls = []

	# List of tags and their respective attributes containing URLs
	url_tags = [
		('a', 'href'),
		('link', 'href'),
		('script', 'src'),
		('img', 'src'),
		('img', 'srcset'),
		('picture', 'srcset'),
		('iframe', 'src'),
		('source', 'src'),
		('embed', 'src'),
		('object', 'data'),
		('video', 'poster'),
		('audio', 'src'),
		('base', 'href'),
		('input', 'src'),
		('area', 'href'),
		('track', 'src'),
		('param', 'value'),
		# ('meta', 'content'),
		('blockquote', 'cite'),
		('q', 'cite'),
		('del', 'cite'),
		('ins', 'cite'),
		('form', 'action'),
		('applet', 'code'),
		('applet', 'archive'),
		('command', 'icon')
	]

	for tag, attr in url_tags:
		for element in soup.find_all(tag, **{attr: True}):
			url = element[attr]
			if base_url:
				url = urllib.parse.urljoin(base_url, url)
			urls.append(url)

	return urls



def scrape_linux_file_paths(text):
	for url in scrape_urls(text):
		text=text.replace(url,'')
	# linux_path_pattern = r'(?<!https?:)\/(?:[^\/\0\s]+\/)*[^\/\0\s]*'
	# linux_path_pattern = r'(?<!https?:)[~\/](?:[^\/\0\s]+\/)*[^\/\0\s]*'
	linux_path_pattern = r'(?<!https?:)(?:~\/|\/)(?:[^\/\0\s]+\/)*[^\/\0\s]*'
	linux_paths = regex.findall(linux_path_pattern, text)
	return set(linux_paths)


def scrape_urls__old(text):
	url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
	urls = re.findall(url_pattern, text)
	return set(urls)

def scrape_urls(text):
	# Regex matches full URLs surrounded by quotes or not
	url_pattern = r'https?://[^\s\'",;]+'
	urls = re.findall(url_pattern, text)
	return set(urls)  # Use set to remove duplicates if needed
	









def extract_huggingface_download_command(text, local_dir='.', symlinks=False):
	# Fix broken slashes from copy-paste formatting
	text = text.replace('\n/', '/').replace('/\n', '/')

	# Extract repo: anything like org_name/repo_name-GGUF
	repo_match = re.search(r'([a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]*-GGUF)', text)
	repo = repo_match.group(1).strip() if repo_match else None

	# Extract filename: any GGUF file
	filename_match = re.search(r'([a-zA-Z0-9_.-]+\.gguf)', text)
	filename = filename_match.group(1).strip() if filename_match else None

	if not repo or not filename:
		return ''
		# raise ValueError("Could not extract model repo or filename from input.")

	# Build huggingface-cli command
	command = (
		f"huggingface-cli download {repo} {filename} "
		f"--local-dir {local_dir} --local-dir-use-symlinks {str(symlinks)}"
	)
	return command





def validate_huggingface_download_command(command: str) -> bool:
	import re
	pattern = (
		r'^huggingface-cli download\s+'
		r'[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+\s+'
		r'[a-zA-Z0-9_.-]+\.gguf\s+'
		r'--local-dir\s+[^\s]+\s+'
		r'--local-dir-use-symlinks\s+(True|False)$'
	)
	return bool(re.match(pattern, command.strip()))








import re
import os
import requests # type: ignore

import re
import os
import requests # type: ignore

def download_json_array(url):
	"""
	Downloads JSON data from a given URL and returns it as a Python list.
	"""
	try:
		response = requests.get(url)
		response.raise_for_status()  # Raise an error for bad status
		data = response.json()
		if isinstance(data, list):
			return data
		else:
			raise ValueError("Expected a JSON array (list), got something else.")
	except Exception as e:
		print(f"Error: {e}")
		return []
def get_cached_tld_list(cache_path='~/.rt/.tlds.json', source_url='https://a.sds.sh/assets/json/TLDs.json'):
	cache_path = os.path.expanduser(cache_path)
	import json
	if os.path.exists(cache_path):
		try:
			return json.loads(_.getText(cache_path,raw=True))
		except:
			return { 'com', 'net', 'org', 'top', 'xyz', 'sh', 'pro', 'rip', 'cx', 'ac', 'cc', 'app', 'solutions', 'menu', 'ing' }  # fallback
	tlds = download_json_array(source_url)
	# tlds = sorted(tlds, key=lambda x: len(x))
	
	_.saveText(json.dumps(tlds, indent=4), cache_path)
	return tlds
	try:
		response = requests.get(source_url)
		response.raise_for_status()
		
		# print(tlds)

	except:
		return { 'com', 'net', 'org', 'top', 'xyz', 'sh', 'pro', 'rip', 'cx', 'ac', 'cc', 'app', 'solutions', 'menu', 'ing' }  # fallback


def extract_domains(text):
	tld_set = { 'com', 'net', 'org', 'top', 'xyz', 'sh', 'pro', 'rip', 'cx', 'ac', 'cc', 'app', 'solutions', 'menu', 'ing' }
	tld_set = get_cached_tld_list()
	# print(tld_set)
	pattern = re.compile(r'\b(?:[a-zA-Z0-9-]+\.)+(?:[a-zA-Z]{2,63})\b')
	# print(pattern)
	domains = []
	# print(domains)
	for match in pattern.findall(text):
		parts = match.lower().split('.')
		if parts[-1] in tld_set:
			if not 'a-zA' in parts[-1] and not '0-9' in parts[-1]:
				m = match.lower()
				if m not in domains:
					domains.append(m)
	return domains

















import re

def scrape_ip_addresses(text):
    """
    Extracts IPv4 and IPv6 addresses from the given text.

    Args:
        text (str): The input text to search.

    Returns:
        dict: Dictionary with 'ipv4' and 'ipv6' lists of unique matches.
    """
    # IPv4 regex (0â€“255 per octet)
    ipv4_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'

    # IPv6 regex (full + shorthand)
    ipv6_pattern = r'\b(?:[A-F0-9]{1,4}:){1,7}[A-F0-9]{1,4}\b'

    ipv4_matches = re.findall(ipv4_pattern, text, flags=re.IGNORECASE)
    ipv6_matches = re.findall(ipv6_pattern, text, flags=re.IGNORECASE)

    # Optional: filter out invalid IPv4 addresses (e.g., 999.999.999.999)
    def valid_ipv4(ip):
        return all(0 <= int(part) <= 255 for part in ip.split('.'))

    ipv4_matches = [ip for ip in ipv4_matches if valid_ipv4(ip)]

    return {
        'ipv4': sorted(set(ipv4_matches)),
        'ipv6': sorted(set(ipv6_matches))
    }





def scrape_all(text):
	windows_paths = scrape_windows_file_paths(text)
	windows_paths2 = scrape_windows_file_paths2(text)
	ips = scrape_ip_addresses(text)

	combined_windows_paths = []

	for path in windows_paths:
		duplicate_found = False

		for path2 in windows_paths2:
			if path2.startswith(path):
				duplicate_found = True
				if path2 not in combined_windows_paths:
					if not ':\\...' in path2 and '\\' in path2 and not '\\...\\' in path2:
						if path2.count('\\') == 1 and "\\'" in path2: pass
						else: combined_windows_paths.append(path2)
				break

		if not duplicate_found and path not in combined_windows_paths:
			if not ':\\...' in path and '\\' in path and not '\\...\\' in path:
				if path.count('\\') == 1 and "\\'" in path: pass
				else: combined_windows_paths.append(path)

	linux_paths = scrape_linux_file_paths(text)
	urls = scrape_urls(text)
	domains = extract_domains(text)
	# print(domains)
	return combined_windows_paths, linux_paths, urls, domains, ips




def is_html(text):
	text=text.strip()
	if not text.startswith('<'): return False


	text=text.lower()

	html_tags = [
		'</title>', '</a>', '<img', '</table>', '</p>', '</ul>',
		'</ol>', '</li>', '</div>', '</span>',
		'</form>', '</input>', '</button>', '</select>',
		'</option>', '</textarea>', '</label>', 
	]
	for tag in html_tags:
		if tag in text:
			return True
	return False    


cleanComment_subject='#'
def cleanComment(line):
	global cleanComment_subject
	sub=cleanComment_subject
	if not sub in line:
		return line.rstrip()
	else:
		if line.strip().startswith(sub): return ''
		triple_quotes = ('"""', "'''")
		single_quotes = ('"', "'")
		in_single_quote = in_double_quote = in_triple_quote = False
		quote_char = None
		result = []

		i = 0
		while i < len(line):
			char = line[i]
			try:
				charN = line[i+1]
			except Exception as e:
				charN = None
			if not (in_single_quote or in_double_quote or in_triple_quote):
				if char == sub[0]:
					if len(sub)>1 and not charN is None and charN == sub[1]:
						break
				if char in single_quotes:
					in_single_quote = True
					quote_char = char
				elif char in triple_quotes and i < len(line) - 2 and line[i:i + 3] in triple_quotes:
					in_triple_quote = True
					quote_char = line[i:i + 3]
					i += 2
				result.append(char)
			else:
				if in_single_quote and char == quote_char:
					in_single_quote = False
				elif in_triple_quote and i < len(line) - 2 and line[i:i + 3] == quote_char:
					in_triple_quote = False
					i += 2
				result.append(char)
			i += 1

		return ''.join(result).rstrip()




def ws_line_cleaner_MF(data):
	data=str(data)
	data = data.replace('\r','')

	lines5=[]
	for i, line in enumerate(data.split('\n')):
		tester=line.replace(' ','').replace('\r','').replace('\t','')
		for elem in string.whitespace:
			while elem in tester: tester = tester.replace(elem, '')
		if len(tester) == 0:
			line=''
		lines5.append(line)
	data5='\n'.join(lines5)
	return data5

def single_space_MF(data):
	data = ws_line_cleaner_MF(data)
	# print('while: b',type(data))
	while '\n\n' in data:data=data.replace('\n\n','\n')
	# print('while: e')
	return data
def py_space_fix_MF(xFiles):
	add_line_before = [
							'#b)-->',
							'########################################################################################',
							'##################################################',
							'_.appInfo[',
							"if __name__ == '__main__':",
							# '',
	]
	add_line_after = [
							'# ## {C3P0D'+'40fAe8B} ##',
							'#!/usr/bin/python3',
							'#e)-->',
							'#n)--> start',
							'##################################################',
							# '',
	]

	lines = []
	for line in xFiles.split('\n'):
		cl_test=line.replace(' ','').replace('\r','').replace('\n','').replace('\t','')

		for rel_str in add_line_before:
			if cl_test.startswith(rel_str.replace(' ','')): lines.append('')
		if cl_test.startswith('def') and cl_test.endswith('):'): lines.append('')

		lines.append(line)

		for rel_str in add_line_after:
			if cl_test.startswith(rel_str.replace(' ','')): lines.append('')
		if line=='}': lines.append('')

	# _.saveText(xFiles,path)
	xFiles = '\n'.join(lines)
	xFiles = xFiles.replace('##################################################\n\n\n##################################################','')
	xFiles = xFiles.replace('##################################################\n\n##################################################','')
	while '\n\n\n' in xFiles: xFiles=xFiles.replace('\n\n\n','\n\n')
	return xFiles


from pynput.keyboard import Key, KeyCode, Controller
keyboard = Controller()

from pynput.keyboard import Listener

__.hotkeysCtrlZ_Ran = time.time()

class HOTKEYS:
	def __init__( self ):
		pass



	def release_key( self, key ):
		if not __.HK.active: return None
		global post_do
		global key_set
		global force_clean
		global no_escape
		if 'PreHook' in post_do:
			# print("post_do=post_do['PreHook'](post_do)",post_do['PreHook'])
			post_do=post_do['PreHook'](post_do)
		try:
			if '_clip_' in post_do['label']:
				# print('is a MF clip')
				__.hotkeysCtrlZ = True
			else:
				__.hotkeysCtrlZ = False
		except Exception as e:
			__.hotkeysCtrlZ = False
		try:
			char = str(key.char)
		except Exception as e:
			# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
			char = str(key).replace("'",'')
		try:
			key_set.remove(char)
		except Exception as e:
			# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
			key_set = set()

		if not key_set and post_do['status']:
			post_do['status'] = 0
			count = post_do['count']
			do = post_do['do']
			k = post_do['label']
			if not k in no_escape:
				if post_do['esc']:
					keyboard.press(Key.esc)
					keyboard.release(Key.esc)

					keyboard.press(Key.esc)
					keyboard.release(Key.esc)

					keyboard.press(Key.esc)
					keyboard.release(Key.esc)

					keyboard.press(Key.esc)
					keyboard.release(Key.esc)

			ii=0
			if ii<count:
				while not ii == count:
					if '_clip_' in post_do['label']:
						# print('is a MF clip')
						if time.time()-__.hotkeysCtrlZ_Ran > .5:
							__.hotkeysCtrlZ_Ran = time.time()
							keyboard.press(Key.ctrl_l)
							keyboard.press('z')
							keyboard.release(Key.ctrl_l)
							keyboard.release('z')
							

						break
					ii+=1
					if __.TroubleShoot.backspace:
						print(444)
					if not post_do['backspace'] == False:
						keyboard.press(Key.backspace)
						keyboard.release(Key.backspace)
			__.shouldBackspace = post_do['backspace']

			if not os.path.isfile(_v.tt+os.sep+'hotkeys-log.csv'): _.saveText('epoch,label',_v.tt+os.sep+'hotkeys-log.csv')
			log=_.getText(_v.tt+os.sep+'hotkeys-log.csv',raw=True).strip()+'\n'
			log+=str(time.time()).split('.')[0]+','+str(k)
			_.saveText(log,_v.tt+os.sep+'hotkeys-log.csv')
			# print(_v.tt+os.sep+'hotkeys-log.csv')
			# for line in log.split('\n'):print(line)
			_.pr(k,c='green')
			if k in force_clean:
				i=0
				# print('force_clean[k]',force_clean[k])
				while not i==force_clean[k]:
					i+=1
					if __.TroubleShoot.backspace:
						print(111)
					if not post_do['backspace'] is False:
						keyboard.press(Key.backspace)
						keyboard.release(Key.backspace)
			exec(do)
			# print('do',do)
			# print('post_do',post_do)
			beepy.simple_beep2()

	def process_keystroke( self, key ):
		if not __.HK.active: return None
		global post_do
		global key_set
		global print_chars
		global ctrl_chars
		# _.clear()
		# _.pr(line=1,c='yellow')
		# _.pr()
		# for x in dir(key):
		#     _.pr(x)
		# _.pr()
		# _.pr(line=1,c='yellow')
		# _.pr()
		# sys.exit()
		try:
			if hasattr(key, 'vk') and 32 <= key.vk <= 126:
				char = chr(key.vk)
			else:
				try:
					char = str(key.char)
				except Exception as e:
					# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
					char = str(key).replace("'",'')
		except:
			# _.pr('Error:',"hasattr(key, 'vk')",c='red')
			char=''
		key_set.add(char)
		if print_chars:
			_.pr('____________')
			_.pr(key_set)
			for x in key_set:
				_.pr(str(x).replace("'",''))
		global log
		global table
		global keyboard
		# _.pr('char:',char)
		# _.pr('key:',key)
		# try: print('key.char:',key.char)
		# except Exception as e: pass
		key = str(key).replace("'", "")
		log.append(key)
		if _.switches.isActive('Print-Keys'):
			_.pr(key)
		log0=log.copy()
		log0.reverse()
		esc=False

		# process set
		for k in table:
			good=True
			count=0
			backspace=None
			if 'backspace' in table[k]:
				backspace=table[k]['backspace']
			else:
				backspace=None

			for kk in key_set:
				found=False
				for i,t in enumerate(table[k]['test']):
					if '.alt' in t.lower():
						esc=True
					if t == '\\':
						if kk == t:
							found=True
					else:
						if kk.lower().startswith(t.lower()):
							found=True
					if not found:
						try:
							# if k == 'reload':
								# _.pr(kk,KeyCode( char=kk ), KeyCode( char=t.lower() ))
							if kk == ctrl_chars[t.lower()]:
							# if kk == KeyCode( char=ctrl_chars[t.lower()] ):
								found=True

						except Exception as e:
							# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
							# _.pr(e)
							pass
				if not found:
					good=False
			if not len(table[k]['test']) == len(key_set):
				good=False
			if good:
				beepy.simple_beep()
				
				if 'PreHook' in table[k]:
					# print("table[k]['PreHook']",table[k]['PreHook'])
					post_do['PreHook'] = table[k]['PreHook']
					if 'PreHookChange' in table[k]:
						post_do['PreHookChange'] = table[k]['PreHookChange']
					else:
						post_do['PreHookChange'] = {}
				else:
					post_do['PreHook'] = PreHook
					post_do['PreHookChange'] = {}
					
				post_do['backspace'] = backspace
				post_do['status'] = 1
				post_do['esc'] = esc
				post_do['count'] = count
				post_do['label'] = k
				post_do['do'] = table[k]['do']

				# ii=0
				# if ii<count:
				#   while not ii == count:
				#       ii+=1
				#       keyboard.press(Key.esc)
				#       keyboard.press(Key.backspace)
				#       keyboard.release(Key.backspace)
				# _.pr(k)
				# exec(table[k]['do'])
				return None
				break

		# process history

		for k in table:
			good=True
			count=0
			for i,t in enumerate(table[k]['test']):
				if 'backspace' in table[k]:
					backspace=table[k]['backspace']
				else:
					backspace=None

				if '.alt' in t.lower():
					esc=True
				try:
					if not t.startswith('Key.'):
						count+=1
					elif t.startswith('Key.space'):
						count+=1

					if t == '\\':
						if not log0[i] == t:
							good=False
							break
					else:
						if not log0[i].startswith(t):
							good=False
							break

				except Exception as e:
					# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
					good=False
					break
			if good:
				beepy.simple_beep()

				if 'PreHook' in table[k]:
					post_do['PreHook'] = table[k]['PreHook']
					if 'PreHookChange' in table[k]:
						post_do['PreHookChange'] = table[k]['PreHookChange']
					else:
						post_do['PreHookChange'] = {}
				else:
					post_do['PreHook'] = PreHook
					post_do['PreHookChange'] = {}

				post_do['backspace'] = backspace
				post_do['status'] = 1
				post_do['esc'] = esc
				post_do['count'] = count
				post_do['label'] = k
				post_do['do'] = table[k]['do']

				# ii=0
				# if ii<count:
				#   while not ii == count:
				#       ii+=1
				#       keyboard.press(Key.esc)
				#       keyboard.press(Key.backspace)
				#       keyboard.release(Key.backspace)
				# _.pr(k)
				# exec(table[k]['do'])
				break
# class Hotkeys:END

def _pad(var): return ' '+str(var)+' '
try:
	import numpy as np
	import sounddevice as sd
except Exception as e:
	pass

class BEEPS:
	def __init__(self):
		###
		# Notes Config
		###

		# Set delay tempo
		self.tempo = 0.15

		# Setup Notes
		self.notes = {
			"pause": 0,
			"c": 1,
			"c#": 2,
			"d": 3,
			"d#": 4,
			"e": 5,
			"f": 6,
			"f#": 7,
			"g": 8,
			"g#": 9,
			"a": 10,
			"a#": 11,
			"b": 12,
		}

		# Note Types
		self.note_types = {
			"sixteenth": 50,
			"eighth": 100,
			"dotted_eighth": 150,
			"quarter": 200,
			"half": 400,
			"whole": 800,
			"triplet": 60,
		}

	def play_note(self, octave, note, note_type):
		# winsound.Beep(250, 1000)
		if _.v.play:
			_beeper.play_note(octave, note, note_type)
		return None
		# _beeper.play_note(octave, note, "whole")
		# _beeper.play_note(octave, note, note_type)
		# _beeper.play_note(3, "c", "half")
		"""Play a note at a certain octave by calculating the frequency of the sound it would represent."""
		pass
		if _.v.play:
			# Match the note and note type to the dictionaries
			note = self.notes[note]
			note_type = self.note_types[note_type]

			# Chill for a bit if it's a pause
			if not note:
				time.sleep(note_type / 1000)
				return

			# Calculate C for the provided octave
			frequency = 32.7032 * (2 ** octave)

			# Calculate the frequency of the given note
			frequency *= 1.059463094 ** note

			# Generate sine wave
			duration = note_type / 1000  # convert to seconds
			sample_rate = 44100
			t = np.arange(int(duration * sample_rate))
			wave = 0.5 * np.sin(2 * np.pi * frequency * t / sample_rate)
			wave = np.int16(wave * 32767)

			# Play the sound
			try:
				_beeper.play_note(octave, note, note_type)
			except:
				pass
			# try:
			#     sd.play(wave, sample_rate)
			#     sd.wait()
			#     # Delay after the beep so it doesn't all run together
			#     time.sleep(self.tempo)
			# except Exception as e:
			#     frameinfo = getframeinfo(currentframe())
			#     print(frameinfo.lineno, '\t', e, 'red')
			#     pass

	def simple_beep(self):
		_oct = 2
		self.play_note(_oct, 'g', 'quarter')

	def simple_beep2(self):
		_oct = 3
		self.play_note(_oct, 'e', 'quarter')

	def note(self, n='c', *args):
		_oct = 3
		nt = 'half'
		for a in args:
			if type(a) == str:
				nt = a
			if type(a) == int:
				_oct = a
		self.play_note(_oct, n, nt)






# class BEEPS:
# 	def __init__( self ):
# 		###
# 		# Notes Config
# 		###

# 		# Set delay tempo
# 		self.tempo = 0.15
# 		# tempo = 1

# 		# Setup Notes
# 		self.notes = {}
# 		self.notes["pause"] = 0
# 		self.notes["c"] = 1
# 		self.notes["c#"] = 2
# 		self.notes["d"] = 3
# 		self.notes["d#"] = 4
# 		self.notes["e"] = 5
# 		self.notes["f"] = 6
# 		self.notes["f#"] = 7
# 		self.notes["g"] = 8
# 		self.notes["g#"] = 9
# 		self.notes["a"] = 10
# 		self.notes["a#"] = 11
# 		self.notes["b"] = 12

# 		# Note Types
# 		self.note_types = {}
# 		self.note_types["sixteenth"] = 50
# 		self.note_types["eigth"] = 100
# 		self.note_types["dotted_eigth"] = 150
# 		self.note_types["quarter"] = 200
# 		self.note_types["half"] = 400
# 		self.note_types["whole"] = 800
# 		self.note_types["triplet"] = 60
# 	def play_note( self, octave, note, note_type ):
# 		"""Play a note at a certain octave by calculating the frequency of the sound it would represent on the motherboard's speaker."""

# 		# Match the note and note type to the dictionaries
# 		note = self.notes[note]
# 		note_type = self.note_types[note_type]

# 		# Chill for a bit if it's a pause
# 		if not note:
# 			time.sleep(note_type/1000)
# 			return

# 		# Calculate C for the provided octave
# 		frequency = 32.7032 * (2**octave)

# 		# Calculate the frequency of the given note
# 		frequency *= 1.059463094**note

# 		# Beep it up
# 		try:
# 			winsound.Beep(int(frequency), note_type)
# 			# Delay after the beep so it doesn't all run together
# 			time.sleep(self.tempo)
# 		except Exception as e:
# 			frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
# 			pass

# 	def simple_beep(self):
# 		_oct = 2
# 		self.play_note(_oct, 'g', 'quarter')

# 	def simple_beep2(self):
# 		_oct = 3
# 		self.play_note(_oct, 'e', 'quarter')
# 	def note(self,n='c',*args):
# 		_oct=3
# 		nt='half'
# 		for a in args:
# 			if type(a) == str: nt=a
# 			if type(a) == int: _oct=a
# 		self.play_note(_oct, n, nt)


def _bk():
	global keyboard
	if __.TroubleShoot.backspace:
		print(222)
	if not __.shouldBackspace == False:
		keyboard.press(Key.backspace)
		keyboard.release(Key.backspace)

class CLIP:



	# def browser_f12(self,code):
	
	# load_clip_3
	def save_clip_0(self):
		secure = _.getText(_v.stmp+os.sep+'ipsum.txt',raw=True,strip=2)
		for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: n = str(n); _.saveText(secure,_v.stmp+os.sep+'hotkeys-save_clip_'+n);
		secure = ''
		for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: n = str(n); _.saveText(secure,_v.stmp+os.sep+'hotkeys-save_clip_'+n);
	def save_clip_1(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_1'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_2(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_2'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_3(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_3'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_6(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_6'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_7(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_7'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_8(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_8'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def save_clip_9(self): _.pr('To toggle paste: clip-auto'); fi = _v.stmp+os.sep+'hotkeys-save_clip_9'; _paste = _.regImp( __.appReg, '-paste' ); _paste.imp.dirty=True; _.saveText(_paste.imp.paste(),fi)
	def load_clip_0(self):
		secure = _.getText(_v.stmp+os.sep+'ipsum.txt',raw=True,strip=2)
		# _bk();_bk();
		for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: n = str(n); _.saveText(secure,_v.stmp+os.sep+'hotkeys-save_clip_');
		secure = ''
		for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: n = str(n); _.saveText(secure,_v.stmp+os.sep+'hotkeys-save_clip_'+n);
	def load_clip_1(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_1';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_2(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_2';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_3(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_3';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_4(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_4';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_5(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_5';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_6(self):
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_6';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_7(self):
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_7';
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')
	def load_clip_8(self):
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_8';
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')

	def load_clip_9(self):
		# _bk();_bk(); 
		fi = _v.stmp+os.sep+'hotkeys-save_clip_9';
		auto = _v.stmp+os.sep+'hotkeys-save_clip-auto';
		if os.path.isfile(fi):
			data = _.getText(fi,raw=True)
		else:
			data = ''
		_copy = _.regImp( __.appReg, '-copy' ); _copy.imp.dirty=True; _copy.imp.copy(data);
		_.pr('To toggle paste: clip-auto')
		if os.path.isfile(auto):
			with keyboard.pressed(Key.ctrl): keyboard.press('v'); keyboard.release('v')

	def databeastLogin(self):
		_copy = _.regImp( __.appReg, '-copy' )
		pa='XanTay98TayXan98!\n'
		_copy.imp.copy( pa, p=0 )
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')



	def pipi(self):
		# active_window_test()
		# _paste = _.regImp( __.appReg, '-paste' )

		# def copy_to_clipboard(text):
		# 	import ctypes
		# 	# Constants
		# 	CF_UNICODETEXT = 13
		# 	GHND = 0x0042

		# 	# Allocate global memory for the text
		# 	h_global_mem = ctypes.windll.kernel32.GlobalAlloc(GHND, (len(text) + 1) * 2)
		# 	lp_global_mem = ctypes.windll.kernel32.GlobalLock(h_global_mem)

		# 	# Copy text into memory
		# 	ctypes.cdll.msvcrt.wcscpy_s(ctypes.c_wchar_p(lp_global_mem), len(text) + 1, text)
		# 	ctypes.windll.kernel32.GlobalUnlock(h_global_mem)

		# 	# Open clipboard and set data
		# 	if ctypes.windll.user32.OpenClipboard(None):
		# 		ctypes.windll.user32.EmptyClipboard()
		# 		ctypes.windll.user32.SetClipboardData(CF_UNICODETEXT, h_global_mem)
		# 		ctypes.windll.user32.CloseClipboard()
		# 		print("[Copied] Ï€ copied to clipboard.")
		# 	else:
		# 		print("âŒ Could not open clipboard.")

		# copy_to_clipboard("Ï€")


		# print(_paste.imp.paste())


		# import pyperclip
		# pyperclip.copy('Ï€')

		# print(_paste.imp.paste())

		_paste = _.regImp( __.appReg, '-paste' )
		backup = _paste.imp.paste()
		import tkinter as tk
		r = tk.Tk()
		r.withdraw()  # Hide the main window
		r.clipboard_clear()
		r.clipboard_append('Ï€ Î» â„µ')
		# r.clipboard_append('Ï€ Î» â„µ Ù‰ Ù» ïº‘ ïº— ïº› ïºŸ ïº£ ïº§ ïº« ïº­ ïº¯ ïº³ ïº· ïº» ï» ï»… ï»‰ ï»‹ ï» ï»‘ ï»• ï»™ ï» ï»¡ ï»¥ ï»© ï»­ ï»±')
		r.update()  # Keep the clipboard content after the script ends
		r.destroy()

		# print(_paste.imp.paste())




		# # import pyperclip
		# # pyperclip.copy('Ï€')
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')
		_copy = _.regImp( __.appReg, '-copy' )
		_copy.imp.copy( backup, p=0 )


	def copy_active_window(self):
		import pygetwindow as gw # type: ignore
		win = gw.getActiveWindow()
		if win:
			win.title
			_copy = _.regImp( __.appReg, '-copy' )
			_copy.imp.copy( win.title, p=0 )
			return win

	def databeastUser(self):
		_copy = _.regImp( __.appReg, '-copy' )
		pa='ssh root@databeast.vp-servers.com'
		_copy.imp.copy( pa, p=0 )
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')

	def pipAndStuff_Paste(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		# _copy.imp.dirty=True
		# _paste.imp.dirty=True

		pa=_paste.imp.paste()


		pa = pa.replace('pip ','pip. ')
		pa = pa.replace('pip.exe ','pip. ')
		
		pa = pa.replace('pip3 ','pip. ')
		pa = pa.replace('pip3.exe ','pip. ')


		_copy.imp.copy( pa, p=0 )
	
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')


	def browser_f12_gen_md_link(self):
		global keyboard
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		_copy.imp.dirty=True
		_paste.imp.dirty=True
		# Subject
		_.pr('NEED TO ADD COOL STUFF HERE',c='Background.red')
		_copy.imp.copy( "var md0='['+document.title+']('+window.location.href+')';\nconsole.log(md0);\ncopy(md0);", p=0 )
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)
		time.sleep(.7)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('`')
			keyboard.release('`')
		time.sleep(.2)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')
		time.sleep(.7)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		time.sleep(.7)
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)


	def browser_f12_tooljs_table(self):
		tooljs=_v.ww+os.sep+'javascript'+os.sep+'tool.js'
		print(tooljs)
		if not os.path.isfile(tooljs):
			_.pr('missing:',tooljs,c='red')
			return None
		global keyboard
		_copy = _.regImp( __.appReg, '-copy' )
		# _copy.imp.dirty=True
		# _paste = _.regImp( __.appReg, '-paste' )
		# _paste.imp.dirty=True
		inject='''
hackTool.hack.instructions = [
	{
		"name": "label",
		"location": "table",
		"type": "table",
		"settings": { "labels": "h2" }
	}
]
hackTool.autoHack();
copy(  hackTool.payload.label  )
'''

		code=_.getText(tooljs,raw=True)+"\n\n"+inject
		# print(code)
		_copy.imp.copy( code, p=0 )
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('`')
			keyboard.release('`')
		time.sleep(.2)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')
		time.sleep(.5)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		time.sleep(.7)
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)



	def browser_f12_tooljs_table0(self):
		tooljs=_v.ww+os.sep+'javascript'+os.sep+'tool.js'
		if not os.path.isfile(tooljs):
			_.pr('missing:',tooljs,c='red')
			return None
		global keyboard
		_copy = _.regImp( __.appReg, '-copy' )
		# _copy.imp.dirty=True
		_paste = _.regImp( __.appReg, '-paste' )
		# _paste.imp.dirty=True
		inject='''
hackTool.hack.instructions = [
	{
		"name": "label",
		"location": "table",
		"type": "table",
		"settings": { }
	}
]
hackTool.autoHack();
copy(  hackTool.payload.label  )
'''
		pa=_paste.imp.paste()
		pax=True
		if not pa: pax=False
		if '\n' in pa: pax=False
		if ' ' in pa and not '.' in pa and not '#' in pa: pax=False
		if pax:
			inject=inject.replace('ELEMENT',pa)
		else:
			inject=inject.replace('ELEMENT','pre')
		code=_.getText(tooljs,raw=True)+"\n\n"+inject
		# print(code)
		_copy.imp.copy( code, p=0 )
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('`')
			keyboard.release('`')
		time.sleep(.2)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')
		time.sleep(.7)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		time.sleep(.7)
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)



	def browser_f12_tooljs_text(self):
		tooljs=_v.ww+os.sep+'javascript'+os.sep+'tool.js'
		if not os.path.isfile(tooljs):
			_.pr('missing:',tooljs,c='red')
			return None
		global keyboard
		_copy = _.regImp( __.appReg, '-copy' )
		# _copy.imp.dirty=True
		_paste = _.regImp( __.appReg, '-paste' )
		# _paste.imp.dirty=True
		inject='''
hackTool.hack.instructions = [
	{
		"name": "label",
		"location": "ELEMENT",
		"type": "list",
		"settings": { "convert": "text" }
	}
]
hackTool.autoHack();
copy(  hackTool.payload.label  )
'''
		pa=_paste.imp.paste()
		pax=True
		if not pa: pax=False
		if '\n' in pa: pax=False
		if ' ' in pa and not '.' in pa and not '#' in pa: pax=False
		if pax:
			inject=inject.replace('ELEMENT',pa)
		else:
			inject=inject.replace('ELEMENT','pre')
		code=_.getText(tooljs,raw=True)+"\n\n"+inject
		# print(code)
		_copy.imp.copy( code, p=0 )
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('`')
			keyboard.release('`')
		time.sleep(.2)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')
		time.sleep(.5)
		keyboard.press(Key.enter)
		keyboard.release(Key.enter)
		time.sleep(.7)
		keyboard.press(Key.f12)
		keyboard.release(Key.f12)


	def extract_text_from_html(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_copy.imp.dirty=True
		_paste = _.regImp( __.appReg, '-paste' )
		_paste.imp.dirty=True
		data  = extract_text_from_webpage(_paste.imp.paste())
		_copy.imp.copy( data, p=0 )


	def test_py(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_copy.imp.dirty=True
		_paste = _.regImp( __.appReg, '-paste' )
		_paste.imp.dirty=True
		data  = _paste.imp.paste()
		data = _.strip_comments(data)
		# _.pr(0)
		# print(data)
		datal = data.split('\n')
		data = '\n'.join(datal)
		# _.pr(line=1,c='r')
		data = _.ephemeral_strip(data)
		data = _str.do('dup',data,'\n')
		while '\t' in data: data=data.replace('\t','    ')
		datal = data.split('\n')
		closest = 9999
		for i,line in enumerate(datal):
			_sp=len(line) - len(line.lstrip())
			if _sp == 0: closest=0
			if _sp < closest: closest=_sp
		# print('closest',closest)
		if not _pad(closest) in ' 9999 0 ':
			for i,line in enumerate(datal):
				datal[i] = line[closest:]
		data = '\n'.join(datal)
		# print(data)
		# _.pr(line=1,c='r')
		_copy.imp.copy( data, p=0 )

	def dup_space(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = single_space_MF(data)
		# data = _str.do('dup',data,'\n')
		_copy.imp.copy( data, p=0 )

	def toLower(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		_copy.imp.copy( data.lower(), p=0 )



	def auto_yaml_json_converter(self):
		_paste = _.regImp( __.appReg, '-paste' )
		data   = _paste.imp.paste()
		if data.startswith('{') or data.startswith('['):
			self.json2yaml()
		else:
			self.yaml2json()



	def yaml2json(self):
		yaml = __.imp('yaml')
		simplejson = __.imp('simplejson')
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\r','')
		lines=[]
		for line in data.split('\n'):
			if line.strip():
				lines.append(line)
		data='\n'.join(lines)
		data = data.replace('\t','    ')
		# _copy.imp.copy( data, p=0 )
		y=yaml.safe_load(data)
		# print(y)
		j = simplejson.dumps(y, indent=4, sort_keys=False, default=str)
		_copy.imp.copy( j, p=0 )

	def json2yaml(self):
		yaml = __.imp('yaml')
		simplejson = __.imp('simplejson')
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\t','    ')
		j = simplejson.loads(data)
		y=yaml.dump( j, sort_keys=False )
		_copy.imp.copy( y, p=0 )

	def d100(self):
		yaml = __.imp('yaml')
		simplejson = __.imp('simplejson')
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\t',' ')
		data = data.replace('\r','')
		data = data.strip()

		lines=[]
		n=1
		first=False
		aline=[]
		for i,line in enumerate(data.split('\n')):
			line=line.strip()
			if not i: listname=line
			if not line == listname and not line == 'd100 Description':
			
				if line == str(n) or line.split(' ')[0] == str(n):
					n+=1
					if aline: lines.append( ' '.join( aline ).replace('  ',' ').replace('  ',' ') )
					aline=[]
				aline.append(line)
		if aline: lines.append( ' '.join( aline ).replace('  ',' ').replace('  ',' ') )
		y = '\n'.join(lines)
		_.saveText(y,'C:\\Users\\Scott\\.rt\\profile\\documents\\dnd\\etsy\\D100 Roll Chart Mega-Pack  DM Tools  PDF  DnD Dungeons & Dragons (5e)  Tabletop RPG\\d100-text\\'+listname.replace(' ','_')+'.txt')
		_copy.imp.copy( y, p=0 )


	def strip1(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\t',' ')
		data = data.replace('\r',' ')
		data = data.strip()

		lines=[]
		n=1
		first=False
		aline=[]
		for i,line in enumerate(data.split('\n')):
			line=line.strip()
			while '  ' in line: line=line.replace('  ',' ')
			if line: lines.append(line)
		y = '\n'.join(lines)

		_copy.imp.copy( y, p=0 )

	def strip2(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\r','')

		lines=[]
		n=1
		first=False
		aline=[]
		data=data.rstrip()
		lines = [line.rstrip() for line in data.split('\n')]
		y = '\n'.join(lines)
		while '\n\n\n' in y: y=y.replace('\n\n\n','\n\n')
		_copy.imp.copy( y, p=0 )


	def base64_encode(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\r','')
		import base64
		data=base64.b64encode(data.encode('utf-8'))
		# data=base64.b64decode(data)
		y=str(data.decode('utf-8'))
		_copy.imp.copy( y, p=0 )

	def base64_decode(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\r','')
		import base64
		# data=base64.b64encode(data)
		data=base64.b64decode(data)
		y=str(data.decode('utf-8'))
		_copy.imp.copy( y, p=0 )

	def space_2_underscore_text(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		while ' ' in data: data=data.replace(' ','_')
		_copy.imp.copy( data, p=0 )

	def toRandomCase(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		_copy.imp.copy( _.randomizeCase(data), p=0 )

	def toUpper(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		_copy.imp.copy( data.upper(), p=0 )

	def reverse_lines(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = cleaner(data,1)
		result = data.split('\n')
		result.reverse()
		_copy.imp.copy(  '\n'.join(result)  , p=0 )

	def ad_notes(self):
		# _copy = _.regImp( __.appReg, '-copy' )
		# _paste = _.regImp( __.appReg, '-paste' )
		# data  = _paste.imp.paste()
		# data = cleaner(data,1)

		# # result.reverse()
		# # _copy.imp.copy(  '\n'.join(result)  , p=0 )

		__.setting('hotkey-clip.ad_description-start1', False)



	def replacer(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = cleaner(data,1)

		a=__.setting('hotkey-clip.replace-a')
		b=__.setting('hotkey-clip.replace-b')
		while a in data:
			data=data.replace(a,b)

		result.reverse()
		_copy.imp.copy(  '\n'.join(data)  , p=0 )


	def space_double(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		# data = cleaner(data,0)
		data = single_space_MF(data)
		data = data.replace( '\n', '\n\n' )
		_copy.imp.copy(  data  , p=0 )



	def quote_inverter(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()

		q1='39fdb0aa0e41'
		q2='baa900bc5061'

		data=data.replace("'",q1)
		data=data.replace('"',q2)
		data=data.replace(q2,"'")
		data=data.replace(q1,'"')
		_copy.imp.copy(  data  , p=0 )



	def remove_dup_spaces(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()

		data = single_space_MF(data)
		# data = data.replace('\r','')
		# data = _str.do('dup',data,'\n')

		_copy.imp.copy(  data  , p=0 )

	def randomize_ports(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace('\r','')
		# data = _str.do('dup',data,'\n')

		for x in range(1000):
			i='{r'+str(x)+'}'
			if i in data:
				port=str(random.randint(1024 , 65535))
				data=data.replace(i,port)
				data=data.replace(i,port)

		_copy.imp.copy(  data  , p=0 )



	def space_single(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = single_space_MF(data)
		# data = cleaner(data,0)
		# while '\n\n' in data:
		#     data=data.replace('\n\n','\n')
		_copy.imp.copy(  data  , p=0 )



	def replacer2(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = cleaner(data)
		lines=data.split('\n')
		a=lines.pop(0)
		b=lines.pop(0)
		k1='1aef6092'
		k2='54e3f6e1'
		c='\n'.join(lines)
		c=c.replace(a,k1);
		c=c.replace(b,k2);
		c=c.replace(k1,b);
		c=c.replace(k2,a);

		_copy.imp.copy(  c  , p=0 )


	def swap(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = cleaner(data)
		def _test_(line):
			line=line.replace(' ','').replace('\t','')
			if len(line): return True
			return False
		def _swap_(line):
			par=[]
			rt=''
			for li in line:
				if _test_(li):
					if li in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ -_"'+'"':
						rt+=li
					else:
						par.append(cleaner(rt)); rt='';
						par.append(li)
			par.append(cleaner(rt))
			if len(par) == 3:
				if ' '+par[1] in line: par[1]=' '+par[1];
				if par[1]+' ' in line: par[1]=par[1]+' ';
				return par[2] + par[1] + par[0]
			return line
		pass
		new=[]
		for lin in data.split('\n'):
			row=_swap_(lin)
			new.append(row)
		_copy.imp.copy(  '\n'.join(new)  , p=0 )




	def dirty_eval(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		try:
			data  = eval( _paste.imp.paste() )
		except Exception as e:
			_.pr(e)

		_copy.imp.copy(  str(data)  , p=0 )

	def builder(self):
		global keyboard
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = cleaner(text,1)
		if not '{}' in text:
			beepy.simple_beep2()
			return None
		
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('x')
			keyboard.release('x')

		time.sleep(.5)
		lines = _paste.imp.paste()
		lines = cleaner(lines,1)
		result = ''
		for line in lines.split('\n'):
			line = cleaner(line)
			result += text.replace( '{}', line ) + '\n'
		result=_str.cleanBE( result, '\n' )
		_copy.imp.copy( result, p=0 )

		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')



	def builder2(self):
		global keyboard
		def build_helper( line, base ):
			fx = '{}'
			parts = []
			fa=_.find_all( base , fx )
			i=0
			lp = line.split(',')
			for ii, pf in enumerate(fa):
				parts.append( base[i:pf] )
				try:
					parts.append( cleaner(lp[ii]) )
				except Exception as e:
					frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
					pass
				i=pf+len(fx)
			parts.append( base[i:] )
			return ''.join(parts)

		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = cleaner(text,1)
		if not '{}' in text:
			beepy.simple_beep2()
			return None

		time.sleep(.5)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('x')
			keyboard.release('x')
		time.sleep(.5)
		lines = _paste.imp.paste()
		lines = cleaner(lines,1)
		result = ''
		for line in lines.split('\n'):
			line = cleaner(line)
			result += build_helper( line, text ) +'\n'
		result=_str.cleanBE( result, '\n' )
		_copy.imp.copy( result, p=0 )

		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')


	def range_first(self):
		def spliter( abc ):
			sp=','
			res = []
			if not sp in abc:
				return abc
			fa=_.find_all( abc , sp )
			a = abc[0:fa[0]]
			b = abc[fa[0]:]
			if not '-' in a:
				return abc

			aa=int(a.split('-')[0])
			bb=int(a.split('-')[1])
			res.append( str(aa)+b )
			while not aa == bb:
				aa+=1
				res.append( str(aa)+b )
			return res

		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = cleaner(text,1)
		result = []
		for line in text.split('\n'):
			line = cleaner(line)
			tx = spliter( line )
			if type(tx) == str:
				result.append(tx)
			else:
				for kk in tx:
					result.append(kk)

		_copy.imp.copy( '\n'.join( result ) , p=0 )







	def Aestiva_List(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		lines=data.split('\n')
		subject = lines.pop(0).strip()
		result = []
		for i,line in enumerate(lines):
			line=line.strip()
			if not line:
				result +='\n'
			else:
				result.append(subject+'['+str(i+1)+'] = "'+line+'"')
		_copy.imp.copy( '\n'.join(result), p=0 )

	def second(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace("'",'')
		data = data.replace('"','')
		data = data.replace('`','')
		data = data.replace(':','=')
		data = data.replace('$','')
		data = data.replace('\t',' ')
		data = cleaner(data,1)

		result = ''
		for line in data.split('\n'):
			line=line.strip()
			if not line:
				result +='\n'
			else:
				if '=' in line:
					result += line.split('=')[1].strip() + '\n'
				else:
					result += line.split(' ')[1] + '\n'
		result=_str.cleanBE( result, '\n' )

		_copy.imp.copy( result, p=0 )

	def second2(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace("'",'')
		data = data.replace('"','')
		data = data.replace('`','')
		data = data.replace(':','=')
		data = data.replace('$','')
		data = data.replace('\t',' ')
		data = cleaner(data,1)

		result = ''
		for line in data.split('\n'):
			line=line.strip()
			if not line:
				result +='\n'
			else:
				if '=' in line:
					result += line.split('=')[1].strip() + '\n'
				else:
					x=line.split(' ')
					x.pop(0)
					result += ' '.join(x) + '\n'
		result=_str.cleanBE( result, '\n' )

		_copy.imp.copy( result, p=0 )

	def first(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace("'",'')
		data = data.replace('"','')
		data = data.replace('`','')
		data = data.replace(':','')
		data = data.replace('$','')
		data = data.replace('=',' ')
		data = data.replace('\t',' ')
		data = cleaner(data,1)

		result = ''
		for line in data.split('\n'):
			line=_str.cleanBE( line, ' ' )
			result += line.split(' ')[0] + '\n'
		result=_str.cleanBE( result, '\n' )

		_copy.imp.copy( result, p=0 )

	def php_var(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace("'",'')
		data = data.replace('"','')
		data = data.replace('`','')
		data = data.replace(':','')
		data = data.replace('$','')
		data = data.replace('=',' ')
		data = data.replace('\t',' ')
		data = cleaner(data,1)

		result = ''
		for line in data.split('\n'):
			line=_str.cleanBE( line, ' ' )
			result += '$'+line.split(' ')[0] + '\n'
		result=_str.cleanBE( result, '\n' )

		_copy.imp.copy( result, p=0 )


	def SQL_to_crud(self):

		define = {
					'int': 'number',
					'tinyint': 'number',
					'smallint': 'number',
					'mediumint': 'number',
					'bigint': 'number',
					'decimal': 'number',
					'float': 'number',
					'bit': 'number',

					# '{}': 'spatial',
					'char': 'text',
					'varchar': 'text',
					'binary': 'text',
					'varbinary': 'text',
					'tinyblob': 'text',
					'blob': 'text',
					'mediumblob': 'text',
					'longblob': 'text',
					'tinytext': 'text',
					'text': 'text',
					'mediumtext': 'text',
					'longtext': 'text',
					'enum': 'text',
					'set': 'text',

					'date': 'date',
					'time': 'date',
					'datetime': 'date',
					'timestamp': 'date',
					'year': 'date',

					'geometry': 'spatial',
					'point': 'spatial',
					'linestring': 'spatial',
					'polygon': 'spatial',
					'geometrycollection': 'spatial',
					'multilinestring': 'spatial',
					'multipoint': 'spatial',
					'multipolygon': 'spatial',
		}


		sql = """

/////////////////////////////////////////////////////////////////// START AUTO-CRUD  THETABLE


function update_one__THETABLE( $ID_label, $FIELD ){
	$FIELD =ingenuity_clean($FIELD);
	dbquery(  "UPDATE THETABLE SET FIELD='$FIELD' WHERE ID_label=ID_data ", false);
}

function add_most__THETABLE( FIELDS_MOST_var_comma ){
	$FIELD_MOST_label =ingenuity_clean($FIELD_MOST_label);
	dbquery(  " INSERT INTO THETABLE (FIELDS_MOST_comma) VALUES (FIELDS_MOST_data_comma);"  ,false);
}

function add_all__THETABLE( FIELDS_ALL_var_comma ){
	$FIELD_ALL_text_label =ingenuity_clean($FIELD_ALL_text_label);
	dbquery(  " INSERT INTO THETABLE (FIELDS_ALL_comma) VALUES (FIELDS_ALL_data_comma);"  ,false);
}

function update_most__THETABLE( $ID_label, FIELDS_MOST_var_comma ){
	$FIELD_MOST_text_label =ingenuity_clean($FIELD_MOST_text_label);
	dbquery(  "
		UPDATE THETABLE SET
			FIELD_MOST_label=FIELD_data
		WHERE ID_label=ID_data
	", false);
}

function update_all__THETABLE( FIELDS_ALL_var_comma ){
	$FIELD_ALL_text_label =ingenuity_clean($FIELD_ALL_text_label);
	dbquery(  "
		UPDATE THETABLE SET
			FIELDS_ALL_label=FIELD_data
		WHERE ID_label=ID_data
	", false);
}

function get__THETABLE( $ID_label ){
	global $theDatabase;
	$query=" SELECT * FROM THETABLE WHERE ID_label=ID_data ORDER BY ID_label DESC";

	$result = $theDatabase->query($query);$i=0;
	while ($row = mysqli_fetch_assoc($result)) {
	$resultArray[$i] = array(
		'FIELDS_ALL_label' => ingenuity_unclean($row['FIELDS_ALL_label']),
		);$i++;}
	if ($i === 0) $resultArray=false;
	return $resultArray;

}

/////////////////////////////////////////////////////////////////// END AUTO-CRUD  THETABLE
		"""
		sq='"'
		q="'"

		invert_quotes = False

		if invert_quotes:
			q='"'
			sq="'"
			sql = sql.replace( '"', '4ED054B5666E' )
			sql = sql.replace( "'", 'E982407E' )
			sql = sql.replace( 'E982407E', '"' )
			sql = sql.replace( '4ED054B5666E', "'" )


		var='$'
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		data = data.replace("'",'')
		data = data.replace('"','')
		data = data.replace('`','')
		data = data.replace('\t',' ')
		data = cleaner(data,1)



		code = ''
		table = ''
		dic = {}
		fields = []
		fields_r = []
		fields_v = []
		fields_vq = []
		fields_v_a = []
		fields_vq_a = []
		skip = []
		for i,line in enumerate(data.split('\n')):
			line = cleaner(line)
			_.pr(line)
			parts = line.split(' ')
			if i == 0:
				if 'CREATE TABLE' in line.upper():
					line = line.replace( '(', ' (' )
					table = parts[2]
				else:
					beepy.simple_beep2()
					return None
			else:
				try:
					dic[parts[0]] = define[parts[1].split('(')[0].lower()]
					fields.append(parts[0])
					if 'DEFAULT 0'.lower() in line.lower() or 'DEFAULT 1'.lower() in line.lower() or 'CURRENT_TIMESTAMP'.lower() in line.lower():
						skip.append( parts[0] )
					elif not i == 1:

						fields_r.append( parts[0] )


				except Exception as e:
					frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
					pass

		# _.pv(fields)
		# _.pv(fields_r)
		# _.pv(skip)
		# _.pv(dic)
		# _.pr( table )


		def field_data(f,t):
			if t == 'number':
				return var+f
			else:
				return q+var+f+q
				return sq+'. ingenuity_clean('+var+f+') .'+sq

		for field in fields:
			fields_v_a.append( var+field )
			fields_vq_a.append( field_data(field,dic[field]) )


		for field in fields_r:
			fields_v.append( var+field )
			fields_vq.append( field_data(field,dic[field]) )

		pass
		skip.append( fields[0] )



		sql = sql.replace( 'THETABLE', table )
		sql = sql.replace( 'ID_label', fields[0] )
		sql = sql.replace( 'ID_data', field_data(fields[0],dic[fields[0]]) )

		sql = sql.replace( 'FIELDS_MOST_var_comma', ', '.join(fields_v) )
		sql = sql.replace( 'FIELDS_MOST_data_comma', ', '.join(fields_vq) )
		sql = sql.replace( 'FIELDS_MOST_comma', ', '.join(fields_r) )

		sql = sql.replace( 'FIELDS_ALL_var_comma', ', '.join(fields_v_a) )
		sql = sql.replace( 'FIELDS_ALL_data_comma', ', '.join(fields_vq_a) )
		sql = sql.replace( 'FIELDS_ALL_comma', ', '.join(fields) )

		for i,line in enumerate(sql.split('\n')):
			if not 'FIELD_MOST_label' in line and not 'FIELD_data' in line and not 'FIELDS_ALL_label' in line and not 'FIELD_ALL_text_label' in line and not 'FIELD_MOST_text_label' in line:
				code += line + '\n'
			else:

				if 'FIELD_ALL_text_label' in line:
					for field in fields:
						if dic[field] == 'text':
							code += line.replace( 'FIELD_ALL_text_label', field ).replace( 'FIELD_data', field_data(field,dic[field]) ) + '\n'

				elif 'FIELD_MOST_text_label' in line:
					for field in fields:
						if dic[field] == 'text':
							code += line.replace( 'FIELD_MOST_text_label', field ).replace( 'FIELD_data', field_data(field,dic[field]) ) + '\n'


				elif 'FIELDS_ALL_label' in line:
					for field in fields:
						code += line.replace( 'FIELDS_ALL_label', field ).replace( 'FIELD_data', field_data(field,dic[field]) ) + '\n'


				else:
					for field in fields_r:
						code += line.replace( 'FIELD_MOST_label', field ).replace( 'FIELD_data', field_data(field,dic[field]) ) + '\n'



		pass




		# THETABLE
		# ID_label
		# ID_data

		# FIELDS_MOST_var_comma
		# FIELDS_MOST_data_comma
		# FIELDS_MOST_comma

		# FIELD_MOST_label
		# FIELD_data
		# FIELDS_ALL_label
		# FIELD_ALL_text_label
		# FIELD_MOST_text_label




		_copy.imp.copy( code, p=0 )


	#       data=_str.cleanBE( data, '\n' )
	# CREATE TABLE `meta_email_schedule` (
	#   `id` int(11) NOT NULL,
	#   `cid` varchar(40) DEFAULT NULL,
	#   `uuid` varchar(40) DEFAULT NULL,
	#   `db` varchar(40) DEFAULT NULL,
	#   `subject` varchar(40) DEFAULT NULL,
	#   `created` varchar(200) DEFAULT NULL,
	#   `sday` varchar(200) DEFAULT NULL,
	#   `stime` varchar(200) DEFAULT NULL,
	#   `last` varchar(200) DEFAULT "",
	#   `json` longblob DEFAULT "",
	#   `counter` int(6) DEFAULT 0,
	#   `expire` varchar(200) DEFAULT "",
	#   `spent` int(1) DEFAULT 0,
	#   `text` int(6) DEFAULT 0,
	#   `cnt` int(6) DEFAULT 1,
	#   `now` int(6) DEFAULT 0,
	#   `status` int(1) DEFAULT 1
	# )


	def win_path(self):
		_copy = _.regImp( __.appReg, '-copy' )
		_paste = _.regImp( __.appReg, '-paste' )
		data  = _paste.imp.paste()
		if '\\\\' in data:
			data = _str.replaceDuplicate(data,'\\')
		else:
			data = _str.replaceDuplicate(data,'\\')
			data = data.replace('\\','\\\\')
		_copy.imp.copy( data, p=0 )

	def reduction_loop(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		if ',' in text:
			par = False
		else:
			par = True
		text = text.replace( '\n', ',' )
		text = text.replace( '\t', '' )
		text = text.replace( ' ', '' )
		text = text.replace( '\r', '' )
		text = _str.cleanBE(text,',')
		text = _str.replaceAll(text,',,',',')
		numbs = []
		for n in text.split(','):
			if len(n):
				n = int(n)
				numbs.append(n)
		l=0
		done=False
		while not done:
			for n in numbs:
				if (not n%2==0):
					done = True


			if not done:
				l+=1
				for i,n in enumerate(numbs):
					numbs[i] = n/2
		pass
		strings = []
		strings.append( str(l)+':' )
		for n in numbs:
			strings.append(str(n).replace('.0',''))

		if par:
			bind = '\n'
		else:
			bind = ', '
		results = bind.join(strings)
		results = results.replace( ':,', ':' )
		_copy.imp.copy( results, p=0 )


	def implode(self):
		try:
			_paste = _.regImp( __.appReg, '-paste' )
			_copy = _.regImp( __.appReg, '-copy' )
			text = _paste.imp.paste()
			text=_str.replaceDuplicate( text, '\n' )
			text=_str.cleanBE( text, '\n' )
			text=_str.cleanBE( text, '\t' )
			text=_str.cleanBE( text, ' ' )
			text = text.replace('\r','')

			text=_str.cleanBE( text, '\n' )
			text=_str.cleanBE( text, '\t' )
			text=_str.cleanBE( text, ' ' )
			text=_str.cleanBE( text, '\n' )
			text=_str.cleanBE( text, '\t' )
			text=_str.cleanBE( text, ' ' )
			if text.startswith('{') or text.startswith('['):
				try:
					data = simplejson.loads(text)
				except Exception as e:
					pass
					# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
					try:
						data = eval(text.replace('false','False').replace('true','True'))
					except Exception as e:
						_.pr(e)
				data = reorder_keys(data)
				result = simplejson.dumps(data, sort_keys=False)
				result=result.replace('{','{ ').replace('}',' }')
				_copy.imp.copy( wt_implode(result), p=0 )
				return None



			# text = text.replace('\n','')
			# text = text.replace(', ',',')
			# text = text.replace(',','\n')

			_copy.imp.copy( text, p=0 )

			text=_str.replaceDuplicate( text, ' ' )
			_copy.imp.copy( text, p=0 )
		except Exception as e:
			_.pr(e)




	def implode_clean(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')

		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		if text.startswith('{') or text.startswith('['):
			try:
				data = simplejson.loads(text)
			except Exception as e:
				frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
				try:
					data = eval(text.replace('false','False').replace('true','True'))
				except Exception as e:
					_.pr(e)
			result = simplejson.dumps(data, sort_keys=False)
			result=result.replace('{','{ ').replace('}',' }')
			_copy.imp.copy( result, p=0 )
			return None
		text = text.replace('\n',' ')
		text = text.replace('\r','')
		# text = text.replace('\n','')
		# text = text.replace(', ',',')
		# text = text.replace(',','\n')

		_copy.imp.copy( text, p=0 )

		text=_str.replaceDuplicate( text, ' ' )
		_copy.imp.copy( text, p=0 )





	def implode3(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')

		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		if text.startswith('{') or text.startswith('['):
			# _.pr(text)
			# sys.exit()
			try:
				data = simplejson.loads(text)
			except Exception as e:
				frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
				try:
					data = eval(text.replace('false','False').replace('true','True'))
				except Exception as e:
					_.pr(e)
			result = '[\n\t'
			records = []
			for record in data:
				records.append( simplejson.dumps(record, sort_keys=False) )
			result += ',\n\t'.join(records)
			result += '\n]'

			result=result.replace('{','{ ').replace('}',' }')
			_copy.imp.copy( result, p=0 )
			return None

	def toString(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')

		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		if text.startswith('{') or text.startswith('['):
			# _.pr(text)
			# sys.exit()
			try:
				data = simplejson.loads(text)
			except Exception as e:
				frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
				try:
					data = eval(text.replace('false','False').replace('true','True'))
				except Exception as e:
					_.pr(e)
			records = []
			for rec in data:
				records.append(rec.replace('\r','').replace('\n',''))

			_copy.imp.copy( '\n'.join(records), p=0 )
			return None



	def prefix(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = text.replace( '\n', '' )
		text = text.replace( '\r', '' )
		text = text.replace( '\t', '' )
		text = _str.cleanBE( text, ' ' )

		time.sleep(1)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('x')
			keyboard.release('x')

		time.sleep(.5)
		lines = _paste.imp.paste()
		lines=_str.cleanBE( lines, '\n' )
		lines = lines.replace('\r','')

		result=''
		for line in lines.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				result += text + ' ' + line + '\n'
			else:
				result += '\n'

		result=_str.cleanBE( result, '\n' )
		_copy.imp.copy( result, p=0 )
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')

	def decrypt_lines(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		_decrypt_docs = _.regImp( __.appReg, 'decrypt-docs' )
		_vault = _.regImp( __.appReg, '_rightThumb._vault' )
		text = _paste.imp.paste()
		text = text.replace('\r','')
		rows = []
		for row in text.split('\n'):
			if _decrypt_docs.imp.identify(row):
				row = _vault.imp.s.de( row )
			rows.append(row)
		_copy.imp.copy( '\n'.join(rows), p=0 )





	def scrape_paths(self):
		import pyautogui # type: ignore

		pyautogui.doubleClick()
		pyautogui.click()
		time.sleep(.1)
		pyautogui.rightClick()

		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste().strip()
		text = text.replace('\\/','/').strip()

		if '.gguf' in text:
			try:
				gguf = extract_huggingface_download_command(str(text))
				_.pr(line=1)
				print(gguf)
				_.pr(line=1)
				if '.gguf' in gguf:
					if validate_huggingface_download_command(gguf):
						_copy.imp.copy( gguf, p=0 )
						return None

			except: pass

		# print(text)
		
		isHTML=is_html(text)

		if isHTML:
			result=extract_urls(text)
		else:
			text = text.replace('â””â”€','')
				

			windows_paths, linux_paths, urls, domains, ips = scrape_all(text)
			result=domains


			for path in windows_paths:
				if not "'" in path:
					result.append(path)
			for path in linux_paths:
				if not "'" in path:
					if path.endswith(';'):
						path=path[:-len(';')]
				result.append(path)
			for path in urls:
				if not "'" in path:
					result.append(path)
			scan = _scan.imp.app.scan.process( text, 'A02F28B2' )
			for k in scan:
				for item in scan[k]:
					if not item in result:
						result.append(item)
			for ip in ips['ipv4']: result.append(ip)
			for ip in ips['ipv6']: result.append(ip)
			# print('ips',ips)


		def cleanScrape(item):
			item=item.strip()
			item=item.replace('[a-zA-Z0-9-]+\.)+(','')
			def csi(item,e):
				if item.endswith(e): item=item[:-len(e)]
				return item
			def csi2(item,e,n):
				if item.endswith(e) and not n in item: item=item[:-len(e)]
				return item

			item=csi(item,',')
			item=csi2(item,')','(')
			item=csi2(item,'}','{')
			item=csi2(item,']','[')
			item=csi2(item,']','[')
			# item=csi2(item,'>','<')
			item=csi(item,"'")
			item=csi(item,'"')
			item=csi(item,'">')
			item=csi(item,'>')
			if '"' in item:
				it=item.split('"')
				if len(it) > 1:
					lengths=[]
					for t in it: lengths.append(len(t))
					lengths.sort(reverse=True)
					for t in it:
						if len(t) == lengths[0]: item=t


			return item
		items=[]
		for i,item in enumerate(result):
			item=cleanScrape(item)
			if not item in items and len(item) > 1:
				# if len(item) == 3 and item.endswith(':/') or (len(item) > 2 and item.startswith('/') and item[2] == ':'):
				if len(item) == 3 and item.endswith(':/') or ( item.startswith('/') and ':' in item ):
					continue
				else:
					items.append(item)

		if not len(items):
			text=text.replace('\t',' ')
			explode=text.split(' ')
			for frag in explode:
				if '.' in frag:
					dots=frag.split('.')
					ldt=len(dots[-1])
					if ldt < 6:
						items.append(frag)

		if not len(items):
			text=text.replace('\t',' ')
			explode=text.split(' ')
			for frag in explode:
				if '.' in frag:
					dots=frag.split('.')
					ldt=len(dots[-1])
					# if ldt < 6:
					items.append(frag)
		result=items    
		items=[]
		for i,item in enumerate(result):
			item=cleanScrape(item)
			if not item in items and len(item) > 1:
				if len(item) == 3 and item.endswith(':/'):
					continue
				else:
					items.append(item)


		if len(items):
			_copy.imp.copy( '\n'.join(items), p=0 )
		else:
			_copy.imp.copy( ' ' , p=0 )

	def center_to_top_comment(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste().strip()
		text = text.replace('\r','').strip()
		first = text.split('\n')[0]
		second = text.split('\n')[1].replace('#','').strip()
		fl=len(first)
		sl=len(second)+2
		fx = fl-sl
		if (fx % 2) == 0:
			even=True
			add1=0
		else:
			add1=1
			even=False
		if even:
			fx=fx-1

		spaces_on_either_side = int(fx/2)

		first_line = "#" + " " * spaces_on_either_side + second + " " * spaces_on_either_side + "#"

		second_line = "#" + " " * spaces_on_either_side + second + " " * (spaces_on_either_side+add1) + '#'

		rows=[]
		rows.append(first)
		rows.append(second_line)
		_copy.imp.copy( '\n'.join(rows), p=0 )





	def md5(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		import _rightThumb._md5 as _hash
		text = _paste.imp.paste()
		text = text.replace('\r','')
		_copy.imp.copy( _hash.string(text), p=0 )


	def encrypt_lines(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		_decrypt_docs = _.regImp( __.appReg, 'decrypt-docs' )
		_vault = _.regImp( __.appReg, '_rightThumb._vault' )
		text = _paste.imp.paste()
		text = text.replace('\r','')
		rows = []
		for row in text.split('\n'):
			row = _vault.imp.s.en( row )
			rows.append(row)
		_copy.imp.copy( '\n'.join(rows), p=0 )

	def encrypt_all(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		_decrypt_docs = _.regImp( __.appReg, 'decrypt-docs' )
		_vault = _.regImp( __.appReg, '_rightThumb._vault' )
		text = _paste.imp.paste()
		text = text.replace('\r','')
		en = _vault.imp.s.en( text )
		_copy.imp.copy( en, p=0 )

	def combine_make(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = text.replace( '\n', '' )
		text = text.replace( '\r', '' )
		text = text.replace( '\t', '' )
		text = _str.cleanBE( text, ' ' )

		time.sleep(1)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('x')
			keyboard.release('x')

		time.sleep(.5)
		lines = _paste.imp.paste()
		lines=_str.cleanBE( lines, '\n' )
		lines = lines.replace('\r','')

		a = lines.split('\n\n')[0].split('\n')
		b = lines.split('\n\n')[1].split('\n')

		result=''
		for i,line in enumerate(a):
			result += text.replace( '{1}', a[i] ).replace( '{2}', b[i] )+'\n'

		result=_str.cleanBE( result, '\n' )
		result=result.replace("''",'"')
		_copy.imp.copy( result, p=0 )
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')


	def suffix(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = text.replace( '\n', '' )
		text = text.replace( '\r', '' )
		text = text.replace( '\t', '' )
		text = _str.cleanBE( text, ' ' )
		time.sleep(1)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		keyboard.press(Key.esc)
		keyboard.release(Key.esc)
		time.sleep(.5)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('x')
			keyboard.release('x')

		time.sleep(.5)
		lines = _paste.imp.paste()
		lines=_str.cleanBE( lines, '\n' )
		lines = lines.replace('\r','')

		project = _.genUUID()
		_.fields.register( project, 'single' )
		for line in lines.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				_.fields.register( project, 'single', line )

		result=''
		for line in lines.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				result += _.fields.value( project, 'single', line ) + ' ' + text + '\n'
			else:
				result += '\n'

		result=_str.cleanBE( result, '\n' )
		_copy.imp.copy( result, p=0 )
		time.sleep(1)
		with keyboard.pressed(Key.ctrl):
			keyboard.press('v')
			keyboard.release('v')


	def number(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		result=''
		i_max=0
		for line in text.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				i_max+=1

		i_char = len(str(i_max))
		i=0
		for line in text.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				i+=1
				if i_char == 4:
					if len(str(i)) == 4:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 3:
						result += str(i)+'  '+line+'\n'
					elif len(str(i)) == 2:
						result += str(i)+'   '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'    '+line+'\n'
				if i_char == 3:
					if len(str(i)) == 3:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 2:
						result += str(i)+'  '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'   '+line+'\n'
				if i_char == 2:
					if len(str(i)) == 2:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'  '+line+'\n'
				if i_char == 1:
					result += str(i)+' '+line+'\n'

			else:
				result += '\n'


		result=_str.cleanBE( result, '\n' )
		# text=_str.replaceDuplicate( result, ' ' )
		_copy.imp.copy( result, p=0 )








	def remove_py_comments_spaces(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		if text.strip().startswith('<'):
			try:
				text = remove_html_comments(text)
			except Exception as e:
				print(e)
				pass
		text=ws_line_cleaner_MF(text)
		text=text.replace('\r','')
		global cleanComment_subject
		if text.count('//') > text.count('#'):
			cleanComment_subject='//'
		else:
			cleanComment_subject='#'

		result = text.split('\n')


		for i, line in enumerate(result): result[i] = cleanComment(result[i])
		data=single_space_MF('\n'.join(result))
		data=py_space_fix_MF(data)
		_copy.imp.copy( data.strip(), p=0 )
		beepy.simple_beep()

		# self.remove_py_comments()
		# # _.waiting(2)
		# self.dup_space()
		# # _.waiting(2)

		# self.remove_py_comments()
		# self.space_single()


	def remove_py_comments(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=text.replace('\r','')
		global cleanComment_subject
		if text.count('//') > text.count('#'):
			cleanComment_subject='//'
		else:
			cleanComment_subject='#'
		result = text.split('\n')

		for i, line in enumerate(result): result[i] = cleanComment(result[i])
		_copy.imp.copy( '\n'.join(result).strip(), p=0 )



	def eol_space(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=text.replace('\r','')
		while ' \n' in text: text=text.replace(' \n','\n')
		while '\t\n' in text: text=text.replace('\t\n','\n')
		_copy.imp.copy( text, p=0 )

		# result = text.split('\n')
		# def cleanEnd(line):
		#   while line.endswith(' '): line = line[:-1]
		#   return line
		# for i, line in enumerate(result): result[i] = cleanEnd(result[i])
		# _copy.imp.copy( '\n'.join(result), p=0 )


	def numberz(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		texts = text.split('\n')
		result=''
		i=0
		for line in texts:
			if len(line.replace(' ','').replace('\t','')):
				i+=1
				result += _.zeros2(i,  len(str(len(texts)))  )+' '+line+'\n'


			else:
				result += '\n'


		result=_str.cleanBE( result, '\n' )
		# text=_str.replaceDuplicate( result, ' ' )
		_copy.imp.copy( result, p=0 )


	def number_a(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		result=''
		i_max=0
		for line in text.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				i_max+=1

		i_char = len(str(i_max))
		i=0
		for line in text.split('\n'):
			i+=1
			if i_char == 4:
				if len(str(i)) == 4:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 3:
					result += str(i)+'  '+line+'\n'
				elif len(str(i)) == 2:
					result += str(i)+'   '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'    '+line+'\n'
			if i_char == 3:
				if len(str(i)) == 3:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 2:
					result += str(i)+'  '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'   '+line+'\n'
			if i_char == 2:
				if len(str(i)) == 2:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'  '+line+'\n'
			if i_char == 1:
				result += str(i)+' '+line+'\n'



		result=_str.cleanBE( result, '\n' )
		# text=_str.replaceDuplicate( result, ' ' )
		_copy.imp.copy( result, p=0 )

	def number_b(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		result=''
		i_max=0
		for line in text.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				i_max+=1

		i_char = len(str(i_max))
		i=0
		for line in text.split('\n'):
			line=_str.cleanBE( line, ' ' )
			if len(line.replace(' ','').replace('\t','')):
				i+=1
				if i_char == 4:
					if len(str(i)) == 4:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 3:
						result += str(i)+'  '+line+'\n'
					elif len(str(i)) == 2:
						result += str(i)+'   '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'    '+line+'\n'
				if i_char == 3:
					if len(str(i)) == 3:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 2:
						result += str(i)+'  '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'   '+line+'\n'
				if i_char == 2:
					if len(str(i)) == 2:
						result += str(i)+' '+line+'\n'
					elif len(str(i)) == 1:
						result += str(i)+'  '+line+'\n'
				if i_char == 1:
					result += str(i)+' '+line+'\n'

			else:
				result += '\n'


		result=_str.cleanBE( result, '\n' )
		# text=_str.replaceDuplicate( result, ' ' )
		_copy.imp.copy( result, p=0 )



	def number_ba(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		# text=_str.replaceDuplicate( text, '\n' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		result=''
		i_max=0
		for line in text.split('\n'):
			if len(line.replace(' ','').replace('\t','')):
				i_max+=1

		i_char = len(str(i_max))
		i=0
		for line in text.split('\n'):
			line=_str.cleanBE( line, ' ' )
			i+=1
			if i_char == 4:
				if len(str(i)) == 4:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 3:
					result += str(i)+'  '+line+'\n'
				elif len(str(i)) == 2:
					result += str(i)+'   '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'    '+line+'\n'
			if i_char == 3:
				if len(str(i)) == 3:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 2:
					result += str(i)+'  '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'   '+line+'\n'
			if i_char == 2:
				if len(str(i)) == 2:
					result += str(i)+' '+line+'\n'
				elif len(str(i)) == 1:
					result += str(i)+'  '+line+'\n'
			if i_char == 1:
				result += str(i)+' '+line+'\n'




		result=_str.cleanBE( result, '\n' )
		# text=_str.replaceDuplicate( result, ' ' )
		_copy.imp.copy( result, p=0 )



	def explode(self):
		try:
			_paste = _.regImp( __.appReg, '-paste' )
			_copy = _.regImp( __.appReg, '-copy' )
			text = _paste.imp.paste()
			text=_str.replaceDuplicate( text, ' ' )
			text=_str.cleanBE( text, '\n' )
			text=_str.cleanBE( text, '\t' )
			text=_str.cleanBE( text, ' ' )
			text=_str.cleanBE( text, '\n' )
			text=_str.cleanBE( text, '\t' )
			text=_str.cleanBE( text, ' ' )
			text = text.replace('\r','')
			text = text.replace('\n','')
			keepcomma=False

			if text.count(';') > text.count(','): text=text.replace(';',',')

			if text.startswith(',,'):
				text=text[2:]
				keepcomma=True
			if text.startswith('{') or text.startswith('['):
				try:
					data = simplejson.loads(text)
				except Exception as e:
					pass
					# frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
				try:
					data = eval(text)
				except Exception as e:
					_.pr(e)
				result = simplejson.dumps(data, indent=4, sort_keys=False)
				_copy.imp.copy( result, p=0 )
				return None
			text = text.replace(', ',',')
			if keepcomma:
				text = text.replace(',',',\n')
			else:
				text = text.replace('\t',',')
				text = text.replace(',','\n')
			_copy.imp.copy( text, p=0 )
		except Exception as e:
			_.pr(e)

	def clean_terminal_copy(self):
		import pyperclip
		import pyautogui

		pyautogui.doubleClick()
		pyautogui.click()
		pyautogui.rightClick()

		clipboard_text = pyperclip.paste()
		clipboard_text = clipboard_text.replace('â””â”€','')
		pyperclip.copy(clipboard_text.strip())

	def math(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text=_str.replaceDuplicate( text, ' ' )
		text = text.replace('\t','')
		text = text.replace('\r','')
		text = text.replace('\n','+')
		text = text.replace(',','+')
		text = text.replace('x','*')
		text = text.replace('X','*')
		text=_str.cleanBE( text, '+' )
		text=_str.cleanBE( text, '*' )
		text=_str.cleanBE( text, '/' )
		text=_str.replaceDuplicate( text, '+' )
		text=_str.replaceDuplicate( text, '*' )
		text=_str.replaceDuplicate( text, '/' )
		string = ''
		for x in text:
			if x in '0123456789/*-+()':
				string +=x
		try:
			result = eval(string)
		except Exception as e:
			_.pr(e)
		# result = sum(map(int, re.findall(r'[+-]?\d+', string)))
		_copy.imp.copy( str(_.addComma( result )), p=0 )

	def dic(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text=_str.replaceDuplicate( text, ' ' )
		text=_str.cleanBE( text, '\n' )
		text=_str.cleanBE( text, '\t' )
		text=_str.cleanBE( text, ' ' )
		text = text.replace('\r','')
		text = text.replace('\n','')
		text = text.replace(', ',',')
		text = text.replace(' ,',',')
		xXx = text.split(',')
		group=[]
		for x in xXx:
			group.append(x+':'+x)
		result = '{'+','.join(group)+'}'
		_copy.imp.copy( result, p=0 )

	def add_slash(self):
		_paste = _.regImp( __.appReg, '-paste' )
		_copy = _.regImp( __.appReg, '-copy' )
		text = _paste.imp.paste()
		text = text.replace('\r','')
		text=_str.cleanBE( text, '\n' )
		text=_str.replaceDuplicate( text, '\n' )
		newText = ''
		for line in text.split('\n'):
			newText += line + '\\\n'

		_copy.imp.copy( newText, p=0 )


	def del_activate(self):
		Timer( .001, self.del_run ).start()

	def del_run(self):
		global log
		global keyboard
		x='x'
		while not x in '123456789':
			# _.pr('x',x)
			log0=log.copy()
			log0.reverse()
			x=log0[0]
		if x in '123456789':
			if __.TroubleShoot.backspace:
				print(333)
			keyboard.press(Key.backspace)
			keyboard.release(Key.backspace)
			# _.pr('y',x)
			x=int(x)
			_paste = _.regImp( __.appReg, '-paste' )
			text = _paste.imp.paste()
			_copy = _.regImp( __.appReg, '-copy' )
			newText = []
			for line in text.split('\n'):
				line=_str.replaceDuplicate( line, ' ' )
				line=_str.cleanBE( line, ' ' )
				parts=line.split(' ')
				i=0
				while not i == x:
					i+=1
					parts.pop(0)
				newLine=' '.join(parts)
				newText.append(newLine)
			_copy.imp.copy( '\n'.join(newText), p=0 )

# class CLIP:END

class TYPING:
	def __init__(self):
		pass

	def ty(self,text,back=0):
		global keyboard
		for t in text:
			self.keyboard_typing(t)

		ii=0
		while not ii == back:
			ii+=1
			keyboard.press(Key.left)
			keyboard.release(Key.left)

	def ty_h(self,k,back=0):
		global keyboard
		global hot_text

		text = hot_text[k]['text']
		text = text.replace('\r','')
		for t in text:
			self.keyboard_typing(t)

		ii=0
		while not ii == back:
			ii+=1
			keyboard.press(Key.left)
			keyboard.release(Key.left)
	def ty_a(self,k,back=0):
		global keyboard
		global auto_text

		text = auto_text[k]['text']
		text = text.replace('\r','')
		for t in text:
			self.keyboard_typing(t)


		ii=0
		while not ii == back:
			ii+=1
			keyboard.press(Key.left)
			keyboard.release(Key.left)


	def type(self,k,back=0): self.ty_a(k,back=0)


	def keyboard_typing(self,t):
		global keyboard
		if t == '\n':
			keyboard.press(Key.enter)
			keyboard.release(Key.enter)
		elif t == '\t':
			keyboard.press(Key.tab)
			keyboard.release(Key.tab)

			# keyboard.press(Key.space)
			# keyboard.release(Key.space)

			# keyboard.press(Key.space)
			# keyboard.release(Key.space)

			# keyboard.press(Key.space)
			# keyboard.release(Key.space)

			# keyboard.press(Key.space)
			# keyboard.release(Key.space)

		else:
			keyboard.press(t)
			keyboard.release(t)
# class TYPE:END

class LOADER:
	def __init__(self):
		pass

	def autoText(self):
		autxt = _v.dbTables  +_v.slash+ 'AutoText.csv'
		if not os.path.isfile(autxt):
			return None
		try:
			raw = _.getText( autxt, raw=True )
		except Exception as e:
			frameinfo = getframeinfo(currentframe()); _.pr( _.addComma(frameinfo.lineno),'\t', e,c='red');
			raw = ''
		if len(raw) < 5:
			return None

		table = {}

		for line in raw.split('\n'):

			c=line.count('%<')
			line = line.replace( '%<', '' )
			if not line == ';':
				if ';' in line:
					f=_.find_all(line,';')
					a=line[0:f[0]]
					b=line[f[0]+1:]
					b = b.replace( '{#crlf#}', '\n' )
					table[a] = {}
					table[a]['text'] = b
					table[a]['back'] = c

		return table

	def flip_table_test(self):
		global table
		for k in table:
			table[k]['test']=[]
			for t in table[k]['raw']:
				if t.startswith('Key.') and not ',' in t:
					table[k]['test'].append(t)
				elif t.startswith('Key.') and ',' in t:
					p=t.split(',')
					n=int(p[1])
					i=0
					while not i == n:
						i+=1
						table[k]['test'].append(p[0])
				else:
					for tt in t:
						table[k]['test'].append(tt)
			table[k]['test'].reverse()

	def add_text(self, add,text,back,note):
		hot_text  = _.getTableDB('hotkeys-Text.dex')
		hot_text[add]={
							'text': text,
							'back': back,
							'note': note,
		}
		_.saveTableDB( hot_text, 'hotkeys-Text.dex' )

	def build_table(self):
		global table
		global hot_text
		global auto_text
		for k in hot_text:
			if len(hot_text[k]['note']):
				table[hot_text[k]['note']] = { 'raw': [ k ], 'do': 'Typing.ty_h("'+k+'",back='+str(hot_text[k]['back'])+')' }
			else:
				table[k] = { 'raw': [ k ], 'do': 'Typing.ty_h("'+k+'",back='+str(hot_text[k]['back'])+')' }

		for k in auto_text:
			table[k] = { 'raw': [ k ], 'do': 'Typing.ty_a("'+k+'",back='+str(auto_text[k]['back'])+')' }
# class LOADER:END

def action():
	beepy.note('a#','quarter',2)
	if _.isData():
		if _.switches.isActive('Key-Subject'):
			global table
			# global table2
			# global auto_text
			# global hot_text
			# global log
			load()
			table
			for k in table:
				# print(k)
				# for y in table[k]: print(y)
				if 'raw' in table[k]: print(table[k]['raw'])
		return None



	if not _.switches.isActive('Key-Subject'):
		if _.switches.isActive('Convert-AutoText'):
			table = Loader.autoText()
			if table:
				_.saveTableDB( table, 'hotkeys-AutoText.dex' )
			return None
		if _.switches.isActive('Add-Text-Trigger'):
			add  = _.switches.value('Add-Text-Trigger')
			text = _.switches.value('Add-Text-Text')
			back = _.switches.value('Add-Text-Back')
			note = _.switches.value('Add-Text-Note')
			if len(back):
				back = int(back)
			else:
				back = 0
			if len(text) < 2:
				_paste = _.regImp( __.appReg, '-paste' )
				text = _paste.imp.paste()
			text = text.replace('\r','')
			Loader.add_text(add,text,back,note)
			return None

	load()


	if _.switches.isActive('Key-Subject'):
		global table2
		omit=[
				'import,os,sys,time,importlib',
		]
		for key in table2:
			txt=str(table2[key])
			# if not key in omit and _.showLine(txt): _.pr(key,'\t','\t'.join(table2[key]['raw']).replace('Key.','').replace('cmd','win'));
			if not key in omit and ( _.showLine(key) or _.showLine(txt) ): _.pr(key,'\t','\t'.join(table2[key]['raw']).replace('Key.','').replace('cmd','win'));
		# a_t=[]
		# for rec in auto_text:
		#     txt=str(rec)
		#     if _.showLine(txt):
		#         k=list(rec.keys())[0]
		#         a_t.append({})
		#         _.pr(rec[ list(rec.keys())[0] ]['raw'])


		return None

	if __.schedulerRun: schedulerRun()
	_.pr( 'EXIT:   Win + esc' )
	# _.pr( line=1,c='gray' )
	# _.pr(  )
	with Listener(on_press=Hotkeys.process_keystroke,on_release=Hotkeys.release_key) as l:
		l.join()


## o minThread 
import sys, os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), 'library', 'threads')))
from MinThread import MinThread

__.HK = _.dot()
__.HK.active = True
__.TroubleShoot = _.dot()
__.TroubleShoot.backspace = False
__.shouldBackspace = None

class vArgs:
	def __init__(self):
		self.active = True		
		self.status = False
		self.callback = False
		self.stopOn = False
		self.keys = []
		self.time = _.dot()
		self.time.start = None
		self.time.expire = None
		self.time.last = None
		self.default = '3ac505ae287e'
	
	def register(self, callback=None,stopOn=None,default='3ac505ae287e',expire=None):
		self.status = True
		self.callback = callback
		self.stopOn = stopOn
		self.keys = []
		self.time.start = time.time()
		self.time.expire = expire
		self.time.last = time.time()

	def activity(self,key):
		if not self.status: return False

		if not key in self.stopOn:
			self.keys.append(key)
		else:
				
			
			if self.callback:
				self.callback(''.join(self.keys))
			self = _.dot()
			self.status = False
			self.keys = []
			self.stopOn = False

		self.time.last = time.time()
		return True
	
__.HK.vArgs = vArgs()

ctrl_chars = {
	'a': '\x01',
	'b': '\x02',
	'c': '\x03',
	'd': '\x04',
	'e': '\x05',
	'f': '\x06',
	'g': '\x07',
	'h': '\x08',
	'i': '\t',
	'j': '\n',
	'k': '\x0b',
	'l': '\x0c',
	'm': '\r',
	'n': '\x0e',
	'o': '\x0f',
	'p': '\x10',
	'q': '\x11',
	'r': '\x12',
	's': '\x13',
	't': '\x14',
	'u': '\x15',
	'v': '\x16',
	'w': '\x17',
	'x': '\x18',
	'y': '\x19',
	'z': '\x1a',
}

def cleaner(subject,deep=0):
	subject=_str.cleanBE( subject, '\n' )          
	subject=_str.cleanBE( subject, '\t' )            
	subject=_str.cleanBE( subject, ' ' )          
	subject = subject.replace('\r','')              

	subject=_str.cleanBE( subject, '\n' )                           
	subject=_str.cleanBE( subject, '\t' )
	subject=_str.cleanBE( subject, ' ' )                     
	subject=_str.cleanBE( subject, '\n' )
	subject=_str.cleanBE( subject, '\t' )            
	subject=_str.cleanBE( subject, ' ' )            
	if deep:
		subject=_str.replaceDuplicate( subject, ' ' )
		subject=_str.replaceDuplicate( subject, '\n' )                 
	return subject

def toggle_chars():
	global print_chars
	if print_chars:
		print_chars = False
	else:
		print_chars = True
	print('print_chars:',print_chars)

def load():
	global table
	global table2
	global auto_text
	global hot_text
	global log
	global toggler
	log = []
	table = {
				'EXIT': { 'raw': [ 'esc.','win.' ], 'do': '__.scheduler_restart=False;__.scheduler_exit=True;sys.exit();'    , 'backspace': False, 'no-esc': True, 'esc': False,  },




				'save_clip_0': { 'raw': [ 'shift.,2', '0' ], 'do': 'Clip.save_clip_0()' },
				'save_clip_1-Haystack__12': { 'raw': [ 'shift.,2', '1' ], 'do': 'Clip.save_clip_1()' },
				'save_clip_2-Needle____12': { 'raw': [ 'shift.,2', '2' ], 'do': 'Clip.save_clip_2()' },
				'save_clip_3': { 'raw': [ 'shift.,2', '3' ], 'do': 'Clip.save_clip_3()' },
				'save_clip_4': { 'raw': [ 'shift.,2', '4' ], 'do': 'Clip.save_clip_4()' },
				'save_clip_5': { 'raw': [ 'shift.,2', '5' ], 'do': 'Clip.save_clip_5()' },
				'save_clip_6': { 'raw': [ 'shift.,2', '6' ], 'do': 'Clip.save_clip_6()' },
				'save_clip_7': { 'raw': [ 'shift.,2', '7' ], 'do': 'Clip.save_clip_7()' },
				'save_clip_8': { 'raw': [ 'shift.,2', '8' ], 'do': 'Clip.save_clip_8()' },
				'save_clip_9': { 'raw': [ 'shift.,2', '9' ], 'do': 'Clip.save_clip_9()' },

				'load_clip_0': { 'raw': [ 'esc.,2', '0' ], 'do': 'Clip.load_clip_0()' },
				'load_clip_1': { 'raw': [ 'esc.,2', '1' ], 'do': 'Clip.load_clip_1()' },
				'load_clip_2': { 'raw': [ 'esc.,2', '2' ], 'do': 'Clip.load_clip_2()' },
				'load_clip_3': { 'raw': [ 'esc.,2', '3' ], 'do': 'Clip.load_clip_3()' },
				'load_clip_4': { 'raw': [ 'esc.,2', '3' ], 'do': 'Clip.load_clip_4()' },
				'load_clip_5': { 'raw': [ 'esc.,2', '4' ], 'do': 'Clip.load_clip_5()' },
				'load_clip_6': { 'raw': [ 'esc.,2', '5' ], 'do': 'Clip.load_clip_6()' },
				'load_clip_7': { 'raw': [ 'esc.,2', '7' ], 'do': 'Clip.load_clip_7()' },
				'load_clip_8': { 'raw': [ 'esc.,2', '8' ], 'do': 'Clip.load_clip_8()' },
				'load_clip_9': { 'raw': [ 'esc.,2', '9' ], 'do': 'Clip.load_clip_9()' },


				'tester': { 'raw': [ 'ctrl.,3', 'test' ], 'do': '_.pr("works!!")' },
				'win-path': { 'raw': [ 'ctrl.,2', 'win' ], 'do': 'Clip.win_path()' },
				'mom': { 'raw': [ 'ctrl.,2', 'mom' ], 'do': 'Typing.ty("your_mother()",back=1)' },
				'pre-clean': { 'raw': [ 'ctrl.,2', 'space.', 'del' ], 'do': 'Clip.del_activate()' },
				'implode': { 'raw': [ 'ctrl.,2', 'space.', 'i' ], 'do': 'Clip.implode()' },
				# 'implode-clean': { 'raw': [ 'ctrl.,2', 'space.', 'i', 'Key.up' ], 'do': 'Clip.implode_clean()' },
				# 'reduction_loop': { 'raw': [ 'alt.', 'shift.', 'win.', 'r' ], 'do': 'Clip.reduction_loop()' },
				'implode2': { 'raw': [ 'alt.', 'win.', 'i' ], 'do': 'Clip.implode()' },







				# 'implode-clean': { 'raw': [ 'shift.', 'alt.', 'win.', 'i' ], 'do': 'Clip.implode()' },
				'implode-clean': { 'raw': [ 'alt.', 'win.', 'Key.down' ], 'do': 'Clip.implode_clean()' },
				'implode3': { 'raw': [ 'alt.', 'shift.', 'i' ], 'do': 'Clip.implode3()' },
				'number': { 'raw': [ 'alt.', 'win.', 'n' ], 'do': 'Clip.number()' },
				'number': { 'raw': [ 'shift.', 'alt.', 'n' ], 'do': 'Clip.numberz()' },
				'number-a': { 'raw': [ 'alt.', 'win.', 'na' ], 'do': 'Clip.number_a()' },
				'number-b': { 'raw': [ 'alt.', 'win.', 'nb' ], 'do': 'Clip.number_b()' },
				'number-ba': { 'raw': [ 'alt.', 'win.', 'nba' ], 'do': 'Clip.number_ba()' },
				'explode': { 'raw': [ 'ctrl.,2', 'space.', 'x' ], 'do': 'Clip.explode()' },
				'remove-py-js-comments': { 'raw': [ 'ctrl.,2', 'space.', 'c' ], 'do': 'Clip.remove_py_comments()' },
				'remove-py-js-comments-and-spaces': { 'raw': [ 'ctrl.,2', 'space.,2', 'c', 's' ], 'do': 'Clip.remove_py_comments_spaces()' },
				'remove-eol-space': { 'raw': [ 'ctrl.,2', 'space.', 'e' ], 'do': 'Clip.eol_space()' },
				'explode2': { 'raw': [ 'alt.', 'win.', 'x' ], 'do': 'Clip.explode()' },
				'add-slash': { 'raw': [ 'shift.,2',  '\\' ], 'do': 'Clip.add_slash()' },
				'comma-to-js-dic': { 'raw': [ 'ctrl.,2', 'space.', 'dic' ], 'do': 'Clip.dic()' },
				
				'prefix': { 'raw': [ 'alt.', 'win.', 'p' ], 'do': 'Clip.prefix()' },
				'suffix': { 'raw': [ 'alt.', 'win.', 's' ], 'do': 'Clip.suffix()' },
				'lower': { 'raw': [ 'alt.', 'win.', 'l' ], 'do': 'Clip.toLower()' },
				'lower2': { 'raw': [ 'ctrl.', 'win.', 'l' ], 'do': 'Clip.toLower()' },
				# 'randomC': { 'raw': [ 'alt.', 'win.', 'k' ], 'do': 'Clip.toRandomCase()' },
				'upper': { 'raw': [ 'alt.', 'win.', 'u' ], 'do': 'Clip.toUpper()' },
				'upper2': { 'raw': [ 'ctrl.', 'win.', 'u' ], 'do': 'Clip.toUpper()' },

				'lower': { 'raw': [ 'shift.', 'win.', 's', 't' ], 'do': 'Clip.toString()' },

				'dup-spaces': { 'raw': [ 'ctrl.', 'win.', 's' ], 'do': 'Clip.dup_space()' },

				'extract-text-from-html': { 'raw': [ 'alt.', 'win.', '9' ], 'do': 'Clip.extract_text_from_html()' },
				'first-word': { 'raw': [ 'alt.', 'win.', '1' ], 'do': 'Clip.first()' },
				'second-word': { 'raw': [ 'alt.', 'win.', '2' ], 'do': 'Clip.second()' },
				'second-word-2': { 'raw': [ 'alt.', 'win.', '3' ], 'do': 'Clip.second2()' },
				'Aestiva-List': { 'raw': [ 'alt.', 'win.', 'l' ], 'do': 'Clip.Aestiva_List()' },
				'first-php-var': { 'raw': [ 'alt.', 'win.', '4' ], 'do': 'Clip.php_var()' },
				# 'builder-one': { 'raw': [ 'alt.', 'win.', 'b' ], 'do': 'Clip.builder()' },
				'builder-two': { 'raw': [ 'alt.', 'win.', 'y' ], 'do': 'Clip.builder2()' },
				'range-first': { 'raw': [ 'alt.', 'win.', '-' ], 'do': 'Clip.range_first()' },
				# 'reverse-lines': { 'raw': [ 'alt.', 'shift.', 'r' ], 'do': 'Clip.reverse_lines()' },
				'reverse-lines': { 'raw': [ 'alt.', 'win.', 'd' ], 'do': 'Clip.combine_make()' },
				'HK-settings-toggle-print-chars': { 'raw': [ 'alt.', 'win.', 't', 'c' ], 'do': 'toggle_chars()' },
				'decrypt-lines': { 'raw': [ 'win.', 'c' ], 'do': 'Clip.decrypt_lines()' },
				'eval-clip': { 'raw': [ 'alt.', 'win.', 'e' ], 'do': 'Clip.dirty_eval()' },

				'sql-crud': { 'raw': [ 'alt.', 'win.', 'c' ], 'do': 'Clip.SQL_to_crud()' },
				# 'ad-notes': { 'raw': [ 'alt.', 'shift.', 'ctrl.', 'a' ], 'do': 'Clip.ad_notes()' },
				# 'clip-replace': { 'raw': [ 'alt.', 'win.', 'r' ], 'do': 'Clip.replacer()' },
				'clip-replace2': { 'raw': [ 'ctrl.,2', 'shift.,1', 'r' ], 'do': 'Clip.replacer2()' },
				'clip-swap': { 'raw': [ 'ctrl.,2', 'shift.', 's' ], 'do': 'Clip.swap()' },
				'clip-single-space': { 'raw': [ 'win.', 'shift.', 'alt.', 's' ], 'do': 'Clip.space_single()' },
				'clip-double-space': { 'raw': [ 'win.', 'shift.', 'alt.', 'd' ], 'do': 'Clip.space_double()' },
				'clip-invert-quotes': { 'raw': [  'alt.', 'win.',  ';' ], 'do': 'Clip.quote_inverter()' },
				# 'clip-invert-quotes': { 'raw': [  'alt.', 'win.',  'r' ], 'do': 'Clip.quote_inverter()' },
				'clip-dup-spaces': { 'raw': [  'ctrl.,2', 'r',  'd', 's' ], 'do': 'Clip.remove_dup_spaces()' },
				# 'clip-randomize-ports': { 'raw': [   'ctrl.', 'shift.', 'r' ], 'do': 'Clip.randomize_ports()' },
				# 'clip-replace': { 'raw': [ 'ctrl.,2',  's' ], 'do': 'Clip.swap()' },
				'clip-test-py': { 'raw': [   'ctrl.,2', 'space.,2', 'p', 'y' ], 'do': 'Clip.test_py()' },
				'f12-console-gen-md-link': { 'raw': [   'shift.,2',   'w',  'm','d'   ], 'do': 'Clip.browser_f12_gen_md_link()' },
				'f12-console-tool.js-text': { 'raw': [   'shift.,2',   'w',  't','x','t'   ], 'do': 'Clip.browser_f12_tooljs_text()' },
				'f12-console-tool.js-text2': { 'raw': [   'shift.,2',   'w',  't','e','x','t'   ], 'do': 'Clip.browser_f12_tooljs_text()' },
				'f12-console-tool.js-table-0': { 'raw': [   'shift.,2',   'w',  't','0'   ], 'do': 'Clip.browser_f12_tooljs_table0()' },
				'f12-console-tool.js-table-h2': { 'raw': [   'shift.,2',   'w',  't','t'   ], 'do': 'Clip.browser_f12_tooljs_table()' },
				'space-2-underscore': { 'raw': [   'space.,2',   's','p','u'   ], 'do': 'Clip.space_2_underscore_text()' },
				
				'yaml-2-json': { 'raw': [   'ctrl.,2',   'y','2','j'   ], 'do': 'Clip.yaml2json()' },
				'json-2-yaml': { 'raw': [   'ctrl.,2',   'j','2','y'   ], 'do': 'Clip.json2yaml()' },

				'd100-cleaner': { 'raw': [   'ctrl.,2',   'd','1','0','0'   ], 'do': 'Clip.d100()' },
				


				'ctrl_a': { 'raw': [   'win.',  'q'   ], 'do': 'ctrl_a()' },
				'ctrl_p': { 'raw': [   'win.',  'p'   ], 'do': 'ctrl_p()' },
				# 'ctrl_w': { 'raw': [   'alt.',  'w'   ], 'do': 'ctrl_w()' },
				# 'win_tab': { 'raw': [   'alt.',  'c'   ], 'do': 'win_tab()' },
				# 'alt_esc': { 'raw': [   'alt.',  'e'   ], 'do': 'alt_esc()' },



				# 'cmd-procmon': { 'raw': [   'ctrl.,2',    'p','r','o','c'   ], 'do': 'cmd__procmon()' },

				'test': { 'raw': [ 'win.',  'alt.', 't' ], 'do': '_test_()' },

				# 'space-strip': { 'raw': [  'esc.,2',  'cln1'    ], 'do': 'Clip.strip1()' },
				'space-strip1': { 'raw': [  'esc.',  'cln1'    ], 'do': 'Clip.strip1()', 'bk': True },
				'space-strip2': { 'raw': [  'esc.',  'cln1'    ], 'do': 'Clip.strip2()', 'bk': True },

				'the-listener': { 'raw': [  'ctrl.','shift.',  'l'    ], 'do': '_listener_()' },

				'base64_encode': { 'raw': [  'ctrl.','shift.',  'eb'    ], 'do': 'Clip.base64_encode()' },
				'base64_decode': { 'raw': [  'ctrl.','shift.',  'db'    ], 'do': 'Clip.base64_decode()' },

				'encrypt_all': { 'raw': [  'ctrl.','alt.',  'en'    ], 'do': 'Clip.encrypt_all()' },
				'decrypt_lines': { 'raw': [  'ctrl.','alt.',  'de'    ], 'do': 'Clip.decrypt_lines()' },


				'center-to-top-comment': { 'raw': [   'ctrl.,4', 'shift.,2',  'center'   ], 'do': 'Clip.center_to_top_comment()' },

				'scrape-paths': { 'raw': [   'ctrl.', 'win.', 'h'   ], 'do': 'Clip.scrape_paths()' },
				'pip-and-stuff': { 'raw': [   'shift.', 'alt.', 'p'   ], 'do': 'Clip.pipAndStuff_Paste()' },
				'databeastLogin': { 'raw': [   'shift.,2', 'e'   ], 'do': 'Clip.databeastLogin()' },
				'databeastUser': { 'raw': [   'alt.,2',  'e'   ], 'do': 'Clip.databeastUser()' },

 
 

				# 'copy_active_window': { 'raw': [   'alt.',  'space.'    ], 'do': 'Clip.copy_active_window()' },
				'FlagFileFolder': { 'raw': [   'alt.',  'space.'    ], 'do': 'FlagFileFolder()' },
				'pi': { 'raw': [   'alt.',  'shift.',  'd'   ], 'do': 'Clip.pi()' },
				'pipi': { 'raw': [     'shift.',   'space.'  ], 'do': 'Clip.pipi()', 'backspace': False, 'no-esc': True, 'esc': False, 'PreHook': capture_active_window, 'PreHookChange': {'backspace': True } },
				'BackupOnSave': { 'raw': [   'alt.',    'b'   ], 'do': 'BackupOnSave()'   , 'backspace': False, 'no-esc': True, 'esc': False,  },
				# 'AirTerminal': { 'raw': [   'alt.',  'a'   ], 'do': 'AirTerminal()'     , 'backspace': False, 'no-esc': True, 'esc': False,  },

				
				
				# 'f12_press': { 'raw': [   'ctrl.,2',  'f'   ], 'do': 'press_f12()'  },
				# 'f12_press2': { 'raw': [   'ctrl.', 'shift.', 'f'   ], 'do': 'press_f12()'  },
				# 'f12_press3': { 'raw': [   'ctrl.', 'alt.',  'f'   ], 'do': 'press_f12()'  },
				'f12_press4': { 'raw': [   'esc.',     'f'   ], 'do': 'press_f12()'  },


	}

	toggles={
				'alt_win_m': {
					'clip-math': { 'raw': [ 'alt.', 'win.', 'M' ], 'do': 'Clip.math()' },
					'clean-terminal-copy': { 'raw': [ 'alt.', 'win.', 'm' ], 'do': 'Clip.clean_terminal_copy()', 'no-esc': True },
				},
	}
	for k in toggler:
		table[toggler[k]]=toggles[k][toggler[k]]


	global force_clean
	global no_escape
	
	for k in table:
		leni=0
		r=[]
		for key in  table[k]['raw']:
			t=key
			t=t.replace('cl.','ctrl.')
			t=t.replace('crl.','ctrl.')
			t=t.replace('ctr.','ctrl.')
			t=t.replace('ctl.','ctrl.')
			t=t.replace('esc.','Key.esc')
			t=t.replace('space.','Key.space')
			t=t.replace('win.','Key.cmd')
			t=t.replace('cmd.','Key.cmd')
			t=t.replace('ctrl.','Key.ctrl')
			t=t.replace('f.','Key.f')
			t=t.replace('shift.','Key.shift')
			t=t.replace('alt.','Key.alt')
			t=t.replace('key.','Key.')
			t=t.replace('Key.win','Key.cmd')
			if '.' in t: r.append(t)
			elif len(t) == 1:  r.append(t)
			else: [(r.append(at))for at in t]

		leni += sum(1 for y in r if len(y) == 1 or 'Key.space' ==  y)
		if 'bk' in table[k] and table[k]['bk']: force_clean[k]=leni
		if 'no-esc' in table[k] and table[k]['no-esc']: no_escape[k]=leni
		table[k]['raw']=r


	table2=table
	auto_text = _.getTableDB('hotkeys-AutoText.dex')
	hot_text  = _.getTableDB('hotkeys-Text.dex')
	Loader.build_table()
	Loader.flip_table_test()
	# _.pv(table)

########################################################################################
def PreHook(post_do): return post_do

def capture_active_window(data={}):
	import pygetwindow as gw # type: ignore
	win = gw.getActiveWindow()
	if win:
		# print("[capture_active_window]", win.title)
		if 'loc-' in win.title:
			if 'PreHookChange' in data:
				for k in data['PreHookChange']:
					data[k] = data['PreHookChange'][k]
					# print('PreHook Changed',k, data['PreHookChange'][k])
					return data
		# print('PreHook: No change')
		return data
		return win


########################################################################################
def ctrl_a():
	global keyboard
	# Press Ctrl+A
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)
	time.sleep(.8)	
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)

	time.sleep(.8)
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)
	keyboard.press(Key.ctrl_l)
	keyboard.press('a')
	keyboard.release('a')
	keyboard.release(Key.ctrl_l)

	# Pause for 123 milliseconds
	time.sleep(1.5)

	numbers = _.switches.value('Password')
	# Type the provided numbers
	for number in numbers:
		keyboard.press(number)
		keyboard.release(number)

	# Press Enter
	keyboard.press(Key.enter)
	keyboard.release(Key.enter)

def ctrl_w():
	global keyboard
	keyboard.press(Key.ctrl_l)
	keyboard.press('w')
	keyboard.release('w')
	keyboard.release(Key.ctrl_l)

def win_tab():
	keyboard.press(Key.cmd)
	keyboard.press(Key.tab)
	keyboard.release(Key.tab)
	keyboard.release(Key.cmd)

def alt_esc():
	keyboard.press(Key.alt)
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)
	keyboard.release(Key.alt)

def ctrl_p():
	global keyboard
	# Press Ctrl+A
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)
	time.sleep(.8)	
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)

	time.sleep(.8)
	keyboard.press(Key.esc)
	keyboard.release(Key.esc)
	keyboard.press(Key.ctrl_l)
	keyboard.press('p')
	keyboard.release('p')
	keyboard.release(Key.ctrl_l)

	# Pause for 123 milliseconds
	time.sleep(1.5)

	numbers = _.switches.value('Password')
	# Type the provided numbers
	for number in numbers:
		keyboard.press(number)
		keyboard.release(number)

	# Press Enter
	keyboard.press(Key.enter)
	keyboard.release(Key.enter)

########################################################################################

import threading
threads = []
_listen = _.regImp( __.appReg, 'listen' )
_listen.switch('Print')

def _listener_():
	# schedulerRun()
	global threads
	t = threading.Thread(target=_listen.action)
	threads.append(t)
	t.start()

########################################################################################


def cmd__procmon(): os.system('start "proc" "D:\\techApps\\ProcessMonitor\\Procmon64.exe"  ')

def _test_(): return None



########################################################################################

Hotkeys=HOTKEYS()
Typing=TYPING()
Loader=LOADER()
Clip=CLIP()
beepy=BEEPS()
key_set = set()
post_do = { 'status': 0 }
print_chars = False
__.setting('hotkey-clip.ad_description-start1', False)
__.setting('hotkey-clip.replace-a', '.eyeformeta.com')
__.setting('hotkey-clip.replace-b', '.m-eta.app')
force_clean={}


import random
import string
# for elem in string.whitespace: sample_str = sample_str.replace(elem, '')

# beepy.note('d#') # (:g e:) c,    c#, d, d#, e, f, f#, g, g#, a, a#
# beepy.note('c')
# beepy.note('c#')
# beepy.note('d',2)
# beepy.note('d#')
# beepy.note('d')
# beepy.note('f')
# beepy.note('f#')
# beepy.note('a')
# sys.exit()
# C:\Users\Scott\.rt\profile\documents\hotkey_combinations.txt
_scan = _.regImp( __.appReg, 'record-cleaner' )
##################################################
toggler={}
toggler['alt_win_m'] = 'clip-math'
toggler['alt_win_m'] = 'clean-terminal-copy'
##################################################
########################################################################################





# def scheduler_job(rec=None):

# 	if rec is None:
# 		# _.pr('scheduler: checking for database changes',r=1)

# 		if os.path.isfile(__.scheduler_db):
# 			mod=_.mod(__.scheduler_db)
# 			if not __.scheduler_mod == mod:
# 				beepy.note('d',2); beepy.note('d',2);
# 				__.scheduler_restart=True
# 				__.scheduler_exit=True
# 		return None

# 	if 'once' in rec: once=True
# 	else: once=False

# 	os.system(rec['command'])
# 	if once:
# 		schedule.clear(_id)
# 		records=_.getTable(__.scheduler_db)
# 		recs=[]
# 		for r in records:
# 			if not rec['id'] == r['id']: recs.append(r)
# 		_.saveTable(recs,__.scheduler_db)
# 		print('Deleted:',_id,rec['id'])

# 	# if rec['beep']: beepy.note('d',3); beepy.note('c#'); beepy.note('d',3)
# 	print('RAN:',_.toYML(rec))
# try:
# 	import schedule
# except Exception as e:
# 	pass

# def schedulerDB():
# 	# _.pr(line=1,c='gray')
# 	# _.pr('scheduler: creating schedule: start',c='gray')
# 	_.pr('scheduler:',c='gray')
# 	for rec in _.getTable(__.scheduler_db):
# 		# print(_.toYML(rec))
# 		if 'command' in rec:
# 			cmd=rec['command']
# 			if '\\rp.bat' in rec['command']:
# 				cmd=cmd.split('\\rp.bat')[1]
# 			cmd=cmd.strip()
# 			if 'days' in rec and is_today_in_days(rec['days']):
# 				cmd+=', Today: '+', '.join(rec['days'])
# 			elif 'days' in rec:
# 				cmd+=', '+', '.join(rec['days'])
# 			_.pr('\t',cmd,c='gray')
# 		if rec['status']:
# 			run=True
# 			if 'days' in rec:
# 				run=False
# 			if 'days' in rec and is_today_in_days(rec['days']):
# 				run=True
# 			if run:
# 				if 'sec' in rec:
# 					schedule.every(int(rec['sec'])).seconds.do(scheduler_job,rec).tag(rec['id'])
# 				elif 'min' in rec:
# 					schedule.every(int(rec['min'])).minutes.do(scheduler_job,rec).tag(rec['id'])
# 				elif 'hour' in rec:
# 					schedule.every(int(rec['hour'])).hours.do(scheduler_job,rec).tag(rec['id'])
# 				elif 'day' in rec and 'at' in rec and _.isNu(rec['day']):
# 					schedule.every(int(rec['day'])).days.at(rec['at']).do(scheduler_job,rec).tag(rec['id'])
# 				pass
# 				# schedule.every().day.at("12:00").do(job).tag(rec['id'])
# 				# schedule.every().day.at("10:30").do(job)
# 				# schedule.every().monday.do(job)
# 				# schedule.every().wednesday.at("13:15").do(job)
# 				# schedule.every(2).days.at("10:30").do(job)
# 				# schedule.every().week.do(job)
# 				# schedule.every().hour.do(job)
# 				# schedule.every(5).seconds.do(job)
# 				# schedule.every().minute.do(job)
# 	# _.pr('scheduler: creating schedule: end',c='gray')
# 	# _.pr(line=1,c='gray')
# import traceback

# def schedulerNoError():
# 	try: scheduler()
# 	except Exception as e:
# 		print('scheduler error',e)
# 		traceback.print_exc()

# def scheduler():
# 	# print('\nscheduler: started\n')
# 	__.scheduler_mod=0
# 	__.scheduler_db=_v.tt+os.sep+'scheduler.json'
# 	schedule.every(1).minute.do(scheduler_job)
# 	if os.path.isfile(__.scheduler_db):
# 		__.scheduler_mod=_.mod(__.scheduler_db)
# 		schedulerDB()
# 	else:
# 		print('scheduler: No Database')


# 	while True:
# 		if __.scheduler_exit: break
# 		schedule.run_pending()
# 		time.sleep(1)
# 	if __.scheduler_restart:
# 		__.scheduler_exit=False
# 		scheduler()

# def schedulerRun():
# 	# ad1acf13-2809-4fb8-aaf0-37ea2a8ce2b5
# 	__.scheduler_exit=False
# 	__.scheduler_restart=True
# 	threads=[]
# 	import threading
# 	# t = threading.Thread(target=scheduler, args=(1,2,3), kwargs={'name':'scott'})
# 	t = threading.Thread(target=schedulerNoError)
# 	threads.append(t)
# 	t.start()

# def is_today_in_days(days_list):
# 	"""Check if today is in the provided list of days."""
# 	return current_day() in days_list

# def current_day():
# 	import datetime
# 	"""Return current day in short form, e.g., 'fri' for Friday."""
# 	now = datetime.datetime.now()
# 	return now.strftime('%a').lower()

# __.schedulerRun=True

























def scheduler_job(rec=None):

	if rec is None:
		# _.pr('scheduler: checking for database changes',r=1)

		if os.path.isfile(__.scheduler_db):
			mod = _.mod(__.scheduler_db)
			if not __.scheduler_mod == mod:
				beepy.note('d', 2); beepy.note('d', 2);
				__.scheduler_restart = True
				__.scheduler_exit = True
		return None

	if 'once' in rec:
		once = True
	else:
		once = False

	if rec['command'].startswith(('http://', 'https://')):
		import webbrowser
		webbrowser.open(rec['command'])
	else:
		os.system(rec['command'])

	if once:
		schedule.clear(rec['id'])
		records = _.getTable(__.scheduler_db)
		recs = [r for r in records if not rec['id'] == r['id']]
		_.saveTable(recs, __.scheduler_db)
		print('Deleted:', rec['id'])

	print('RAN:', _.toYML(rec))

try:
	import schedule
except Exception as e:
	pass

def schedulerDB():
	_.pr('scheduler:', c='gray')
	for rec in _.getTable(__.scheduler_db):
		if 'command' in rec:
			cmd = rec['command']
			if '\\rp.bat' in rec['command']:
				cmd = cmd.split('\\rp.bat')[1]
			cmd = cmd.strip()
			if 'days' in rec and is_today_in_days(rec['days']):
				cmd += ', Today: ' + ', '.join(rec['days'])
			elif 'days' in rec:
				cmd += ', ' + ', '.join(rec['days'])
			_.pr('\t', cmd, c='gray')
		if rec['status']:
			run = True
			if 'days' in rec:
				run = False
			if 'days' in rec and is_today_in_days(rec['days']):
				run = True
			if run:
				if 'sec' in rec:
					schedule.every(int(rec['sec'])).seconds.do(scheduler_job, rec).tag(rec['id'])
				elif 'min' in rec:
					schedule.every(int(rec['min'])).minutes.do(scheduler_job, rec).tag(rec['id'])
				elif 'hour' in rec:
					schedule.every(int(rec['hour'])).hours.do(scheduler_job, rec).tag(rec['id'])
				elif 'day' in rec and 'at' in rec and _.isNu(rec['day']):
					schedule.every(int(rec['day'])).days.at(rec['at']).do(scheduler_job, rec).tag(rec['id'])

import traceback

def schedulerNoError():
	try:
		scheduler()
	except Exception as e:
		print('scheduler error', e)
		traceback.print_exc()

def scheduler():
	__.scheduler_mod = 0
	__.scheduler_db = _v.tt + os.sep + 'scheduler.json'
	schedule.every(1).minute.do(scheduler_job)
	if os.path.isfile(__.scheduler_db):
		__.scheduler_mod = _.mod(__.scheduler_db)
		schedulerDB()
	else:
		print('scheduler: No Database')

	while True:
		if __.scheduler_exit:
			break
		schedule.run_pending()
		time.sleep(1)
	if __.scheduler_restart:
		__.scheduler_exit = False
		scheduler()

def schedulerRun():
	__.scheduler_exit = False
	__.scheduler_restart = True
	threads = []
	import threading
	t = threading.Thread(target=schedulerNoError)
	threads.append(t)
	t.start()

def is_today_in_days(days_list):
	return current_day() in days_list

def current_day():
	import datetime
	now = datetime.datetime.now()
	return now.strftime('%a').lower()

__.schedulerRun = False

# if __.schedulerRun: zschedulerRun()


























if __name__ == '__main__':
	# schedulerRun()
	if len(_.switches.all())==0: banner.pr();
	if len(_.switches.all())==1 and _.switches.isActive('Password'): banner.pr();
	action()
	__.isExit()


# dup_space

# toRandomCase
#   crashes
# count+=1
# release_key
# cleanComment
# scrape_paths
# scrape_windows_file_paths2
# _beeper
