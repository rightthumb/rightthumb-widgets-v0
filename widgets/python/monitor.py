from __future__ import annotations

import _rightThumb._construct as __;appDBA=__.clearFocus(__name__,__file__);__.appReg=appDBA;import _rightThumb._base3 as _; # type: ignore
def focus(parentApp='', childApp='', reg=True): global appDBA; f = __.appName(appDBA, parentApp, childApp); return f if reg else f
fieldSet=_.l.vars(focus(),__name__,__file__,appDBA);_.load();_v=__.imp('_rightThumb._vars')

def sw():
    pass
    _.switches.register( 'RunOnce', ',-1,-one')
    _.switches.register( 'Hosts', '-ip,-h,-host,-hosts','89.0.142.86', isData='name')
    _.switches.register( 'URLs', '-u,-url,-urls','http://example.com' )
    _.switches.register( 'HostLabels', '-hl')
    _.switches.register( 'UrlLabels', '-ul')
    
_._default_settings_()

_.appInfo[focus()] = {
    'file': 'thisApp.py',
    'description': 'Changes the world',
    'categories': [
                        'DEFAULT',
                ],
    'examples': [
                        _.hp('p thisApp -file file.txt'),
                        _.linePrint(label='simple',p=0),
                        '',
    ],
    'columns': [
    ],
    'aliases': [],
    'relatedapps': [],
    'prerequisite': [],
    'notes': [],
}

_.appInfo[focus()] = _.appInfoContinuity(__.thisApp( __file__ ),_.appInfo[focus()])
_.appData[focus()] = _.appDataContinuity()
def appRegDics(): return { 'appInfo': _.appInfo[focus()], 'appData': _.appData[focus()] }

def triggers():
    _._default_triggers_()
    _.switches.trigger( 'Files',   _.isFileAdvanced, vs=False )     # Advanced File Registration    (Fn Alias Resolves To: def myFileLocations)
    _.switches.trigger( 'DB', _.aliasesFi )
    _.switches.trigger( 'Folder', _.myFolderLocations )
    _.switches.trigger( 'Folders', _.myFolderLocations )
    __.SwitchesModifier.Trigger['Folders'] = _.myFolder
    _.switches.trigger( 'OutputFolder', _.aliasesFo )
def _local_(do): exec(do)
_.l.conf('clean-pipe',True); _.l.sw.register( triggers, sw )
########################################################################################
#n)--> start







import os
import sys
import platform
import subprocess

# ding("online" if ok else "offline")

def ding(status: str):
    """
    Play a sound depending on status.
    status = "online"  → success sound
    status = "offline" → error/fail sound
    """

    status = status.lower().strip()

    # Windows (powershell beep frequency + duration)
    if os.name == "nt":
        try:
            if status == "online":
                subprocess.call(["powershell", "-c", "[console]::beep(1000,150)"])
            else:
                subprocess.call(["powershell", "-c", "[console]::beep(500,400)"])
            return
        except Exception:
            pass

    # macOS (afplay)
    if platform.system() == "Darwin":
        try:
            if status == "online":
                subprocess.call(["afplay", "/System/Library/Sounds/Pop.aiff"])
            else:
                subprocess.call(["afplay", "/System/Library/Sounds/Basso.aiff"])
            return
        except Exception:
            pass

    # Linux (uses 'paplay' or terminal bell as fallback)
    if platform.system() == "Linux":
        try:
            if status == "online":
                subprocess.call(["paplay", "/usr/share/sounds/freedesktop/stereo/complete.oga"])
            else:
                subprocess.call(["paplay", "/usr/share/sounds/freedesktop/stereo/dialog-error.oga"])
            return
        except Exception:
            # As fallback → normal terminal bell
            sys.stdout.write("\a")
            sys.stdout.flush()
            return

    # FINAL fallback for any OS
    sys.stdout.write("\a")
    sys.stdout.flush()










#!/usr/bin/env python3
"""
service_monitor.py

Professional Monitoring Utility

Monitors:
- Hosts (IP/FQDN + TCP port)
- URLs with optional content checks

Features:
- ANSI color output
- Live terminal title updates: "P: x, F: y"
- Clean architecture ready for expansion

Author: You (Generated by ChatGPT)
"""


import dataclasses
import socket
import sys
import time
import urllib.request
from typing import List, Optional, Tuple
import os


# ============================
# ANSI Colors / Title Helpers
# ============================

class Colors:
    ENABLED = sys.stdout.isatty()

    RESET = "\033[0m" if ENABLED else ""
    BOLD = "\033[1m" if ENABLED else ""

    RED = "\033[31m" if ENABLED else ""
    GREEN = "\033[32m" if ENABLED else ""
    YELLOW = "\033[33m" if ENABLED else ""
    CYAN = "\033[36m" if ENABLED else ""
    MAGENTA = "\033[35m" if ENABLED else ""


def set_terminal_title(title: str) -> None:
    """Cross-platform terminal title update."""
    try:
        if os.name == "nt":
            os.system(f"title {title}")
        else:
            sys.stdout.write(f"\033]0;{title}\007")
            sys.stdout.flush()
    except Exception:
        pass


# ====================
# Target Data Classes
# ====================

@dataclasses.dataclass
class HostTarget:
    host: str
    port: int = 80
    timeout: float = 3.0
    name: Optional[str] = None

    def label(self) -> str:
        return self.name or f"{self.host}:{self.port}"


@dataclasses.dataclass
class URLTarget:
    url: str
    required_text: Optional[str] = None   # NEW → Optional text requirement
    timeout: float = 5.0
    name: Optional[str] = None

    def label(self) -> str:
        return self.name or self.url


# ====================
# Main Monitor Class
# ====================

class ServiceMonitor:

    def __init__(self):
        self.hosts: List[HostTarget] = []
        self.urls: List[URLTarget] = []
        self.last = {}

        self.pass_count = 0
        self.fail_count = 0

    # --------------------
    # Registration methods
    # --------------------

    def add_host1(self, host: str, port: int = 80,
                 timeout: float = 3.0, name: Optional[str] = None):
        self.hosts.append(HostTarget(host, port, timeout, name))

    def add_host(self, host: str, port: int = 80,
                timeout: float = 3.0, name: Optional[str] = None):

        # Detect "host" with no port → use ICMP ping
        if ":" not in host:
            port = 0  # ICMP mode

        # detect host:port if provided
        elif ":" in host and not host.startswith('['):
            h, p = host.rsplit(':', 1)
            try:
                port = int(p)
                host = h
            except:
                pass

        self.hosts.append(HostTarget(host, port, timeout, name))


    def add_url(self, url: str,
                required_text: Optional[str] = None,
                timeout: float = 5.0,
                name: Optional[str] = None):
        """
        required_text is OPTIONAL.
        If None → any HTTP 200-399 response counts as PASS.
        """
        self.urls.append(URLTarget(url, required_text, timeout, name))

    # ------------------------
    # Logging + Title handling
    # ------------------------

    def _log(self, msg: str, color="", bold=False):
        prefix = ""
        if bold:
            prefix += Colors.BOLD
        if color:
            prefix += color
        print(f"{prefix}{msg}{Colors.RESET}")

    def _update_title(self):
        if self.pass_count and self.fail_count:
            set_terminal_title(f"P: {self.pass_count}, F: {self.fail_count}")
        if self.pass_count and not self.fail_count:
            set_terminal_title(f"All OK: {self.pass_count}")
        if not self.pass_count and self.fail_count:
            set_terminal_title(f"All FAIL: {self.fail_count}")

    # -------------------
    # Check Functions
    # -------------------

    def _check_host1(self, target: HostTarget) -> Tuple[bool, str]:
        try:
            socket.gethostbyname(target.host)
            with socket.create_connection((target.host, target.port), timeout=target.timeout):
                return True, "Host reachable"
        except Exception as e:
            return False, str(e)

    def _check_host(self, target: HostTarget) -> Tuple[bool, str]:

        # ICMP MODE when port == 0
        if target.port == 0:
            return ping_host(target.host, timeout=target.timeout)

        # TCP MODE (default)
        try:
            socket.gethostbyname(target.host)
            with socket.create_connection((target.host, target.port), timeout=target.timeout):
                return True, "Host reachable"
        except Exception as e:
            return False, str(e)


    def _check_url(self, target: URLTarget) -> Tuple[bool, str]:
        try:
            req = urllib.request.Request(target.url, headers={
                "User-Agent": "ServiceMonitor/1.0"
            })
            with urllib.request.urlopen(req, timeout=target.timeout) as r:
                body = r.read().decode("utf-8", errors="ignore")
                status = r.status

            # PASS logic
            if target.required_text:
                if target.required_text in body:
                    return True, f"Required text found"
                else:
                    return False, f"Missing required text: '{target.required_text}'"

            # If no required text → any 200-399 pass
            if 200 <= status < 400:
                return True, f"HTTP OK ({status})"
            else:
                return False, f"HTTP Status {status}"

        except Exception as e:
            return False, str(e)

    # -----------------
    # Run the checks
    # -----------------

    def run_once1(self):
        """Perform one full pass over all targets."""

        # ---- Hosts ----
        for h in self.hosts:
            ok, info = self._check_host(h)
            # Host = h.host
            if not h.host in self.last: self.last[h.host] = ok
            if not ok == self.last[h.host]:
                ding("online" if ok else "offline")
            self.last[h.host] = ok
            if ok:
                self.pass_count += 1
                self._log(f"[PASS] HOST ┇ {h.label()} ┇ {info}",
                          Colors.GREEN, bold=True)
            else:
                self.fail_count += 1
                self._log(f"[FAIL] HOST ┇ {h.label()} ┇ {info}",
                          Colors.RED, bold=True)

        # ---- URLs ----
        for u in self.urls:
            ok, info = self._check_url(u)
            if ok:
                self.pass_count += 1
                self._log(f"[PASS] URL  ┇ {u.label()} ┇ {info}",
                          Colors.GREEN, bold=True)
            else:
                self.fail_count += 1
                self._log(f"[FAIL] URL  ┇ {u.label()} ┇ {info}",
                          Colors.RED, bold=True)

        self._update_title()


    def run_once(self):
        """Perform one full pass over all targets."""

        # current state for this cycle only
        pass_now = 0
        fail_now = 0

        # ---- HOSTS ----
        for h in self.hosts:
            ok, info = self._check_host(h)

            key = f"{h.host}:{h.port}"
            if key not in self.last:
                self.last[key] = ok
            if ok != self.last[key]:
                ding("online" if ok else "offline")
            self.last[key] = ok

            if ok:
                pass_now += 1
                self._log(f"[PASS] HOST ┇ {h.label()} ┇ {info}",
                        Colors.GREEN, bold=True)
            else:
                fail_now += 1
                self._log(f"[FAIL] HOST ┇ {h.label()} ┇ {info}",
                        Colors.RED, bold=True)

        # ---- URLs ----
        for u in self.urls:
            ok, info = self._check_url(u)

            key = f"url:{u.url}"
            if key not in self.last:
                self.last[key] = ok
            if ok != self.last[key]:
                ding("online" if ok else "offline")
            self.last[key] = ok

            if ok:
                pass_now += 1
                self._log(f"[PASS] URL  ┇ {u.label()} ┇ {info}",
                        Colors.GREEN, bold=True)
            else:
                fail_now += 1
                self._log(f"[FAIL] URL  ┇ {u.label()} ┇ {info}",
                        Colors.RED, bold=True)

        # update title with *current* totals
        self.pass_count = pass_now
        self.fail_count = fail_now
        self._update_title()


    def run_forever(self, interval: int = 5):
        """Continuous monitor loop."""
        try:
            while True:
                self.run_once()
                self._log(f"--- Sleeping {interval}s ---", Colors.CYAN)
                time.sleep(interval)
        except KeyboardInterrupt:
            self._log("Exiting monitor.", Colors.MAGENTA, bold=True)


def ping_host(host: str, timeout: float = 2.0) -> Tuple[bool, str]:
    """
    ICMP ping using system ping.
    Works on Windows, Linux, macOS.
    """
    import platform
    import subprocess

    param = "-n" if platform.system().lower() == "windows" else "-c"
    timeout_flag = "-w" if platform.system().lower() == "windows" else "-W"

    cmd = [
        "ping",
        param, "1",
        timeout_flag, str(int(timeout)),
        host
    ]

    try:
        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if p.returncode == 0:
            return True, "Ping OK"
        else:
            return False, "No ping reply"
    except Exception as e:
        return False, str(e)


'''
from service_monitor import ServiceMonitor

mon = ServiceMonitor()
mon.add_host("1.1.1.1", 53, name="Cloudflare DNS")
mon.add_url("https://example.com", name="Homepage")
mon.add_url("https://example.com/login", required_text="Login", name="Login Check")
mon.run_once()


'''

'''
mon.run_forever(interval=15)
'''





def action():
    mon = ServiceMonitor()


    # Hosts URLs HostLabels UrlLabels

    for i,host in enumerate( _.switches.values('Hosts') ):
        label = None
        if _.switches.isActive('HostLabels'):
            labels = _.switches.values('HostLabels')
            if i < len(labels):
                label = labels[i]
        mon.add_host( host, name=label )

    for i,url in enumerate( _.switches.values('URLs') ):
        label = None
        if _.switches.isActive('UrlLabels'):
            labels = _.switches.values('UrlLabels')
            if i < len(labels):
                label = labels[i]
        mon.add_url( url, name=label )
    
    if _.switches.isActive('RunOnce'):
        mon.run_once()
    else:
        mon.run_forever()


########################################################################################
if __name__ == '__main__':
    action(); _.isExit(__file__)